'use strict';

var utils = require('@react-rxjs/utils');
var rxjs = require('rxjs');
var blake2b = require('@noble/hashes/blake2b');
var polkadotApi = require('polkadot-api');
var scaleTs = require('scale-ts');

function partitionEntries(entries$) {
  return utils.partitionByKey(
    entries$.pipe(
      rxjs.mergeMap(
        (v) => v.deltas ? [
          ...v.deltas.deleted.map((d) => ({
            id: d.args.at(-1),
            value: void 0
          })),
          ...v.deltas.upserted.map((d) => ({
            id: d.args.at(-1),
            value: d.value
          }))
        ].sort((a, b) => a.id - b.id) : []
      )
    ),
    (res) => res.id,
    (group$) => group$.pipe(
      rxjs.takeWhile(({ value }) => Boolean(value), false),
      rxjs.map(({ value }) => value)
    )
  );
}

const preimageCache = /* @__PURE__ */ new Map();
const getPreimageResolver = (getPreimageValues) => {
  const batched = batch(
    (preimages) => getPreimageValues(preimages.map((v) => [v]))
  );
  return async (proposal) => {
    if (proposal.type === "Legacy")
      throw new Error("Legacy proposals can't be resolved");
    if (proposal.type === "Inline") return proposal.value;
    const cached = preimageCache.get(proposal.value.hash.asHex());
    if (cached) return cached;
    const promise = (async () => {
      const result = await batched([proposal.value.hash, proposal.value.len]);
      if (!result)
        throw new Error(`Preimage ${proposal.value.hash.asHex()} not found`);
      return result;
    })();
    preimageCache.set(proposal.value.hash.asHex(), promise);
    return promise;
  };
};
const batch = (fn) => {
  let batched = null;
  async function execute() {
    if (!batched) return;
    try {
      const result = await fn(batched.map((v) => v.value));
      batched.forEach(({ resolve }, i) => resolve(result[i]));
    } catch (ex) {
      console.error(ex);
      batched.forEach(({ reject }) => reject(ex));
    }
    batched = null;
  }
  return (value) => new Promise((resolve, reject) => {
    if (!batched) {
      batched = [
        {
          value,
          resolve,
          reject
        }
      ];
      setTimeout(execute);
    } else {
      batched.push({
        value,
        resolve,
        reject
      });
    }
  });
};

const SpenderOrigin = {
  Treasurer: "Treasurer",
  SmallTipper: "SmallTipper",
  BigTipper: "BigTipper",
  SmallSpender: "SmallSpender",
  MediumSpender: "MediumSpender",
  BigSpender: "BigSpender"
};
const originToTrack = {
  Treasurer: "treasurer",
  SmallTipper: "small_tipper",
  BigTipper: "big_tipper",
  SmallSpender: "small_spender",
  MediumSpender: "medium_spender",
  BigSpender: "big_spender"
};
const DOT_UNIT = 10000000000n;
const polkadotSpenderOrigin = (value) => {
  if (value <= 250n * DOT_UNIT) return SpenderOrigin.SmallTipper;
  if (value <= 1000n * DOT_UNIT) return SpenderOrigin.BigTipper;
  if (value <= 10000n * DOT_UNIT) return SpenderOrigin.SmallSpender;
  if (value <= 100000n * DOT_UNIT) return SpenderOrigin.MediumSpender;
  if (value <= 1000000n * DOT_UNIT) return SpenderOrigin.BigSpender;
  if (value <= 10000000n * DOT_UNIT) return SpenderOrigin.Treasurer;
  return null;
};
const KSM_UNIT = 1000000000000n;
const kusamaSpenderOrigin = (value) => {
  if (value <= 1n * KSM_UNIT) return SpenderOrigin.SmallTipper;
  if (value <= 5n * KSM_UNIT) return SpenderOrigin.BigTipper;
  if (value <= 333n * KSM_UNIT) return SpenderOrigin.SmallSpender;
  if (value <= 3333n * KSM_UNIT) return SpenderOrigin.MediumSpender;
  if (value <= 33333n * KSM_UNIT) return SpenderOrigin.BigSpender;
  return SpenderOrigin.Treasurer;
};

const keyBy = (arr, mapFn) => Object.fromEntries(Array.from(arr).map((v) => [mapFn(v), v]));

function enhanceTrack(track) {
  return {
    ...track,
    minApproval: curveToFunctionDetails(
      track.decision_period,
      track.min_approval
    ),
    minSupport: curveToFunctionDetails(
      track.decision_period,
      track.min_support
    )
  };
}
function trackFetcher(typedApi) {
  const referendaTracksPromise = typedApi.constants.Referenda.Tracks().then(
    (tracks) => {
      const byId = Object.fromEntries(tracks);
      const byName = keyBy(Object.values(byId), (v) => v.name);
      return { byId, byName };
    }
  );
  return async (id) => {
    const referendaTracks = await referendaTracksPromise;
    const track = typeof id === "number" ? referendaTracks.byId[id] : referendaTracks.byName[id];
    if (!track) return null;
    return enhanceTrack(track);
  };
}
const BILLION = 1e9;
const BIG_BILLION = 1000000000n;
const blockToPerBill = (block, period) => BigInt(block) * BIG_BILLION / BigInt(period);
const perBillToBlock = (perBillion, period) => perBillion == null ? Number.POSITIVE_INFINITY : Number(bigDivCeil(perBillion * BigInt(period), BIG_BILLION));
const perBillToPct = (perBillion) => Number(perBillion) / BILLION;
function curveToFunctionDetails(period, curve) {
  const curveFn = curve.type === "LinearDecreasing" ? linearDecreasing(curve.value) : curve.type === "SteppedDecreasing" ? steppedDecreasing(curve.value) : reciprocal(curve.value);
  return {
    curve,
    getThreshold(at) {
      return curveFn.getValue(blockToPerBill(at, period));
    },
    getBlock(pct) {
      return perBillToBlock(curveFn.getTime(pct), period);
    },
    getData(step = 1) {
      return curveFn.getData(blockToPerBill(Math.max(step, 1), period)).map(({ time, value }) => ({
        block: perBillToBlock(time, period),
        threshold: perBillToPct(value)
      }));
    }
  };
}
const bigCap = (value, cap) => {
  if (cap.floor != null) value = value < cap.floor ? cap.floor : value;
  if (cap.ceil != null) value = value < cap.ceil ? cap.ceil : value;
  return value;
};
const bigDivCeil = (a, b) => {
  const floor = a / b;
  return a % b === 0n ? floor : floor + 1n;
};
function linearDecreasing(params) {
  const { length, floor, ceil } = {
    length: BigInt(params.length),
    floor: BigInt(params.floor),
    ceil: BigInt(params.ceil)
  };
  const getValue = (at) => bigCap(ceil + at * (floor - ceil) / length, {
    floor,
    ceil
  });
  const getTime = (value) => {
    if (value > ceil) return 0n;
    if (value < floor) return null;
    return (value - ceil) * length / (floor - ceil);
  };
  const getData = () => [
    {
      time: 0n,
      value: ceil
    },
    {
      time: length,
      value: floor
    },
    ...BIG_BILLION > length ? [
      {
        time: BIG_BILLION,
        value: floor
      }
    ] : []
  ];
  return { getValue, getTime, getData };
}
function steppedDecreasing(params) {
  const { begin, end, step, period } = {
    begin: BigInt(params.begin),
    end: BigInt(params.end),
    step: BigInt(params.step),
    period: BigInt(params.period)
  };
  const getValue = (at) => bigCap(begin - at / period * step, {
    ceil: begin,
    floor: end
  });
  const getTime = (value) => {
    if (value > begin) return 0n;
    if (value < end) return null;
    return (begin - value) / step * period;
  };
  const getData = () => {
    const result = [];
    for (let k = 0n, value = begin; value > end; value -= step) {
      result.push({
        time: k * period,
        value
      });
    }
    if ((begin - end) % step != 0n) {
      result.push({
        time: (begin - end) / step * period,
        value: end
      });
    }
    if (result.at(-1)?.time < BIG_BILLION) {
      result.push({
        time: BIG_BILLION,
        value: end
      });
    }
    return result;
  };
  return { getValue, getTime, getData };
}
function reciprocal({
  factor,
  x_offset,
  y_offset
}) {
  const getValue = (at) => BIG_BILLION * factor / (at + x_offset) + y_offset;
  const getTime = (value) => {
    if (value <= y_offset) return null;
    if (x_offset != 0n && value > BIG_BILLION * factor / x_offset + y_offset)
      return 0n;
    return BIG_BILLION * factor / (value - y_offset) - x_offset;
  };
  const getData = (step) => {
    const result = [];
    for (let time = 0n; time <= BIG_BILLION; time += step) {
      result.push({ time, value: getValue(time) });
    }
    if (result.at(-1)?.time < BIG_BILLION) {
      result.push({
        time: BIG_BILLION,
        value: getValue(BIG_BILLION)
      });
    }
    return result;
  };
  return { getValue, getTime, getData };
}

const MAX_INLINE_SIZE = 128;
const defaultConfig = {
  spenderOrigin: polkadotSpenderOrigin
};
function createReferendaSdk(typedApi, config) {
  const { spenderOrigin } = { ...defaultConfig, ...config };
  const resolvePreimage = getPreimageResolver(
    typedApi.query.Preimage.PreimageFor.getValues
  );
  const getTrack = trackFetcher(typedApi);
  function enhanceOngoingReferendum(id, referendum) {
    const resolveProposal = () => resolvePreimage(referendum.proposal);
    async function getConfirmationStart() {
      const totalVotes = referendum.tally.ayes + referendum.tally.nays;
      if (totalVotes == 0n || !referendum.deciding) {
        return null;
      }
      if (referendum.deciding.confirming) {
        return referendum.deciding.confirming;
      }
      const [track, totalIssuance, inactiveIssuance] = await Promise.all([
        getTrack(referendum.track),
        typedApi.query.Balances.TotalIssuance.getValue(),
        typedApi.query.Balances.InactiveIssuance.getValue()
      ]);
      if (!track) return null;
      const approvals = BIG_BILLION * referendum.tally.ayes / totalVotes;
      const support = BIG_BILLION * referendum.tally.support / (totalIssuance - inactiveIssuance);
      const approvalBlock = track.minApproval.getBlock(approvals);
      const supportBlock = track.minSupport.getBlock(support);
      const block = Math.max(approvalBlock, supportBlock);
      if (block === Number.POSITIVE_INFINITY) return null;
      return referendum.deciding.since + block;
    }
    async function getConfirmationEnd() {
      if (!referendum.deciding) return null;
      const track = await getTrack(referendum.track);
      if (!track) return null;
      const confirmationStart = referendum.deciding.confirming ?? await getConfirmationStart();
      if (!confirmationStart) return null;
      return confirmationStart + track.confirm_period;
    }
    return {
      ...referendum,
      type: "Ongoing",
      id,
      proposal: {
        rawValue: referendum.proposal,
        resolve: resolveProposal,
        decodedCall: async () => {
          const proposal = await resolveProposal();
          const token = await typedApi.compatibilityToken;
          return typedApi.txFromCallData(proposal, token).decodedCall;
        }
      },
      async getDetails(subscanApiKey) {
        const result = await fetch(
          "https://polkadot.api.subscan.io/api/scan/referenda/referendum",
          {
            method: "POST",
            body: JSON.stringify({
              referendum_index: id
            }),
            headers: {
              "x-api-key": subscanApiKey
            }
          }
        ).then((r) => r.json());
        return {
          title: result.data.title
        };
      },
      getConfirmationStart,
      getConfirmationEnd,
      async getTrack() {
        const track = await getTrack(referendum.track);
        if (!track) {
          throw new Error("Track not found");
        }
        return track;
      },
      outcome: null,
      async getExpectedOutcome() {
        const confirmationEnd = await getConfirmationEnd();
        return confirmationEnd ? {
          side: referendum.tally.ayes > referendum.tally.nays ? "aye" : "nay",
          ended: confirmationEnd
        } : null;
      }
    };
  }
  function enhanceReferendumInfo(id, info) {
    if (info.type === "Ongoing") return enhanceOngoingReferendum(id, info.value);
    if (info.type === "Killed")
      return {
        type: "Killed",
        block: info.value,
        submission_deposit: void 0,
        decision_deposit: void 0,
        outcome: null
      };
    const [block, submission_deposit, decision_deposit] = info.value;
    return {
      type: info.type,
      block,
      submission_deposit,
      decision_deposit,
      outcome: info.type === "Approved" ? { side: "aye", ended: block } : info.type === "Rejected" ? {
        side: "nay",
        ended: block
      } : null
    };
  }
  async function getReferenda() {
    const entries = await typedApi.query.Referenda.ReferendumInfoFor.getEntries();
    return entries.map(
      ({ keyArgs: [id], value: info }) => enhanceReferendumInfo(id, info)
    );
  }
  async function getReferendum(id) {
    const referendum = await typedApi.query.Referenda.ReferendumInfoFor.getValue(id);
    return referendum ? enhanceReferendumInfo(id, referendum) : null;
  }
  const [rawReferendumById$, referendaKeyChange$] = partitionEntries(
    typedApi.query.Referenda.ReferendumInfoFor.watchEntries()
  );
  const getReferendumById$ = (id) => rawReferendumById$(id).pipe(
    rxjs.map((entry) => enhanceReferendumInfo(id, entry))
  );
  const referenda$ = utils.combineKeys(referendaKeyChange$, getReferendumById$);
  const referendaIds$ = referendaKeyChange$.pipe(
    utils.toKeySet(),
    rxjs.map((set) => [...set])
  );
  const getSpenderTrack = (value) => {
    const spenderOriginType = spenderOrigin(value);
    const origin = spenderOriginType ? {
      type: "Origins",
      value: {
        type: spenderOriginType,
        value: void 0
      }
    } : {
      type: "system",
      value: { type: "Root", value: void 0 }
    };
    return {
      origin,
      track: getTrack(
        spenderOriginType ? originToTrack[spenderOriginType] : "root"
      ).then((r) => {
        if (!r) {
          throw new Error(`Track ${spenderOriginType ?? "root"} not found`);
        }
        return r;
      })
    };
  };
  const createReferenda = (origin, proposal, options) => {
    const enactment_moment = options?.enactment ?? {
      type: "After",
      value: 0
    };
    if (proposal.asBytes().length <= MAX_INLINE_SIZE) {
      return typedApi.tx.Referenda.submit({
        enactment_moment,
        proposal: {
          type: "Inline",
          value: proposal
        },
        proposal_origin: origin
      });
    }
    const hash = blake2b.blake2b(proposal.asBytes());
    return typedApi.tx.Utility.batch_all({
      calls: [
        // Expose the deposit required for the preimage
        // maybe as part of fee + deposit
        typedApi.tx.Preimage.note_preimage({
          bytes: proposal
        }).decodedCall,
        typedApi.tx.Referenda.submit({
          enactment_moment,
          proposal: {
            type: "Lookup",
            value: {
              hash: polkadotApi.Binary.fromBytes(hash),
              len: proposal.asBytes().length
            }
          },
          proposal_origin: origin
        }).decodedCall
      ]
    });
  };
  const createSpenderReferenda = (callData, value) => {
    const spenderTrack = getSpenderTrack(value);
    return createReferenda(spenderTrack.origin, callData);
  };
  const getSubmittedReferendum = (txEvent) => "events" in txEvent ? typedApi.event.Referenda.Submitted.filter(txEvent.events)[0] ?? null : null;
  return {
    watch: {
      referenda$,
      getReferendumById$,
      referendaIds$
    },
    getReferenda,
    getReferendum,
    getSpenderTrack,
    getTrack,
    createReferenda,
    createSpenderReferenda,
    getSubmittedReferendum
  };
}

const ZERO = new Array(32).fill(0);
const createId = (...parts) => {
  const arr = [...ZERO];
  let i = 0;
  parts.forEach((p) => p.forEach((v) => arr[i++] = v));
  return new Uint8Array(arr);
};
const bountyIdPrefix = polkadotApi.Binary.fromText("modlpy/trsry\bbt").asBytes();
const getBountyAccount = (id) => polkadotApi.AccountId().dec(createId(bountyIdPrefix, scaleTs.u32.enc(id)));
const childBountyIdPrefix = polkadotApi.Binary.fromText("modlpy/trsry\bbc").asBytes();
const getChildBountyAccount = (parentId, id) => polkadotApi.AccountId().dec(createId(childBountyIdPrefix, scaleTs.u32.enc(parentId), scaleTs.u32.enc(id)));

const getBountyDescriptions$ = (getEntries, getValues, keyChanges$) => rxjs.merge(
  rxjs.defer(getEntries),
  keyChanges$.pipe(
    rxjs.skip(1),
    rxjs.mergeMap((changes) => {
      if (changes.type === "remove") return [];
      const keys = Array.from(changes.keys);
      return getValues(keys.map((key) => [key])).then(
        (result) => result.map((value, i) => ({
          keyArgs: [keys[i]],
          value
        })).filter(({ value }) => value != null)
      );
    })
  )
).pipe(
  rxjs.scan(
    (acc, v) => ({
      ...acc,
      ...Object.fromEntries(
        v.map(({ keyArgs, value }) => [keyArgs[0], value.asText()])
      )
    }),
    {}
  ),
  rxjs.startWith({}),
  rxjs.shareReplay({ bufferSize: 1, refCount: true })
);

const keyedMemo = (fn, cache) => (...arg) => {
  if (cache.has(arg[0])) return cache.get(arg[0]);
  const result = fn(...arg);
  cache.set(arg[0], result);
  return result;
};
const memo = (fn) => {
  let cachedKey = null;
  let cachedValue = null;
  return (...arg) => {
    if (cachedKey && cachedKey.every((k, i) => k === arg[i])) {
      return cachedValue;
    }
    cachedKey = arg;
    cachedValue = fn(...arg);
    return cachedValue;
  };
};

const spenderOrigins = [
  "Treasurer",
  "SmallSpender",
  "MediumSpender",
  "BigSpender",
  "SmallTipper",
  "BigTipper"
];
const getDecodedSpenderReferenda = keyedMemo(
  async (ongoingReferenda) => {
    const spenderReferenda = ongoingReferenda.filter(
      (ref) => ref.origin.type === "Origins" && spenderOrigins.includes(ref.origin.value.type) || ref.origin.type === "system" && ref.origin.value.type === "Root"
    );
    const response = await Promise.all(
      spenderReferenda.map(
        (referendum) => referendum.proposal.decodedCall().then((call) => ({
          referendum,
          call
        })).catch((ex) => {
          console.error(ex);
          return null;
        })
      )
    );
    return response.filter((v) => !!v);
  },
  /* @__PURE__ */ new WeakMap()
);
async function findApprovingReferenda(ongoingReferenda, bountyId) {
  const spenderReferenda = await getDecodedSpenderReferenda(ongoingReferenda);
  return spenderReferenda.filter(
    ({ call }) => findCalls(
      {
        pallet: "Bounties",
        name: "approve_bounty"
      },
      call
    ).some((v) => v?.bounty_id === bountyId)
  ).map(({ referendum }) => referendum);
}
async function findProposingCuratorReferenda(ongoingReferenda, bountyId) {
  const spenderReferenda = await getDecodedSpenderReferenda(ongoingReferenda);
  return spenderReferenda.map(({ call, referendum }) => {
    const proposeCuratorCalls = findCalls(
      {
        pallet: "Bounties",
        name: "propose_curator"
      },
      call
    ).filter(
      (v) => v?.bounty_id === bountyId && typeof v.curator === "object" && typeof v.fee === "bigint"
    ).map((v) => ({
      curator: v.curator,
      fee: v.fee
    }));
    if (!proposeCuratorCalls.length) return null;
    return { referendum, proposeCuratorCalls };
  }).filter((v) => v !== null);
}
const findCalls = (call, obj) => {
  if (typeof obj !== "object") return [];
  if (Array.isArray(obj)) {
    const approves2 = [];
    for (const item of obj) approves2.push(...findCalls(call, item));
    return approves2;
  }
  if (obj?.type === call.pallet && obj?.value?.type === call.name) {
    return [obj.value.value];
  }
  const approves = [];
  for (const key of Object.keys(obj))
    approves.push(...findCalls(call, obj[key]));
  return approves;
};

const scheduledFinder = (typedApi) => {
  const resolvePreimage = getPreimageResolver(
    typedApi.query.Preimage.PreimageFor.getValues
  );
  const getScheduledCalls = memo(async () => {
    const agenda = await typedApi.query.Scheduler.Agenda.getEntries();
    const token = await typedApi.compatibilityToken;
    const scheduled = agenda.flatMap(
      ({ keyArgs: [height], value: values }) => values?.filter((v) => !!v).map((value) => ({
        height,
        call: value.call
      })) ?? []
    );
    const resolvedCalls = await Promise.all(
      scheduled.map(
        ({ height, call }) => resolvePreimage(call).then(
          (callData) => typedApi.txFromCallData(callData, token).decodedCall
        ).then((decodedCall) => ({ height, call: decodedCall })).catch((ex) => {
          console.error(ex);
          return null;
        })
      )
    );
    return resolvedCalls.filter((v) => !!v);
  });
  async function findScheduledApproved(bountyId) {
    const calls = await getScheduledCalls();
    return calls.filter(
      ({ call }) => findCalls({ pallet: "Bounties", name: "approve_bounty" }, call).some(
        (v) => v?.bounty_id === bountyId
      )
    ).map(({ height }) => height);
  }
  async function findScheduledCuratorProposed(bountyId) {
    const calls = await getScheduledCalls();
    return calls.map(({ call, height }) => {
      const proposeCuratorCalls = findCalls(
        {
          pallet: "Bounties",
          name: "propose_curator"
        },
        call
      ).filter(
        (v) => v?.bounty_id === bountyId && typeof v.curator === "object" && typeof v.fee === "bigint"
      ).map((v) => ({
        curator: v.curator,
        fee: v.fee
      }));
      if (!proposeCuratorCalls.length) return null;
      return { height, proposeCuratorCalls };
    }).filter((v) => v !== null);
  }
  return { findScheduledApproved, findScheduledCuratorProposed };
};

function createBountiesSdk(typedApi) {
  const { findScheduledApproved, findScheduledCuratorProposed } = scheduledFinder(typedApi);
  const enhanceBounty = (bounty, description, id) => {
    const generic = {
      ...bounty,
      type: bounty.status.type,
      id,
      description,
      account: getBountyAccount(id)
    };
    switch (generic.status.type) {
      case "Proposed":
        return {
          ...generic,
          type: "Proposed",
          approve() {
            return typedApi.tx.Bounties.approve_bounty({ bounty_id: id });
          },
          close() {
            return typedApi.tx.Bounties.close_bounty({ bounty_id: id });
          },
          filterApprovingReferenda(referenda) {
            return findApprovingReferenda(referenda, id);
          },
          getScheduledApprovals() {
            return findScheduledApproved(id);
          }
        };
      case "Approved":
        return { ...generic, type: "Approved" };
      case "Funded":
        return {
          ...generic,
          type: "Funded",
          proposeCurator(curator, fee) {
            return typedApi.tx.Bounties.propose_curator({
              bounty_id: id,
              curator: {
                type: "Id",
                value: curator
              },
              fee
            });
          },
          close() {
            return typedApi.tx.Bounties.close_bounty({ bounty_id: id });
          },
          filterProposingReferenda(referenda) {
            return findProposingCuratorReferenda(referenda, id);
          },
          getScheduledProposals() {
            return findScheduledCuratorProposed(id);
          }
        };
      case "CuratorProposed":
        return {
          ...generic,
          ...generic.status.value,
          type: "CuratorProposed",
          acceptCuratorRole() {
            return typedApi.tx.Bounties.accept_curator({ bounty_id: id });
          },
          unassignCurator() {
            return typedApi.tx.Bounties.unassign_curator({ bounty_id: id });
          },
          close() {
            return typedApi.tx.Bounties.close_bounty({ bounty_id: id });
          }
        };
      case "Active":
        return {
          ...generic,
          type: "Active",
          curator: generic.status.value.curator,
          updateDue: generic.status.value.update_due,
          extendExpiry(remark) {
            return typedApi.tx.Bounties.extend_bounty_expiry({
              bounty_id: id,
              remark: polkadotApi.Binary.fromText(remark ?? "")
            });
          },
          award(beneficiary) {
            return typedApi.tx.Bounties.award_bounty({
              bounty_id: id,
              beneficiary: {
                type: "Id",
                value: beneficiary
              }
            });
          },
          unassignCurator() {
            return typedApi.tx.Bounties.unassign_curator({ bounty_id: id });
          },
          close() {
            return typedApi.tx.Bounties.close_bounty({ bounty_id: id });
          }
        };
      case "PendingPayout":
        return {
          ...generic,
          type: "PendingPayout",
          curator: generic.status.value.curator,
          unlockAt: generic.status.value.unlock_at,
          beneficiary: generic.status.value.beneficiary,
          claim() {
            return typedApi.tx.Bounties.claim_bounty({ bounty_id: id });
          },
          unassignCurator() {
            return typedApi.tx.Bounties.unassign_curator({ bounty_id: id });
          }
        };
    }
    throw new Error("Unreachable");
  };
  function watchBounties() {
    const [getBountyById$, bountyKeyChanges$] = partitionEntries(
      typedApi.query.Bounties.Bounties.watchEntries()
    );
    const descriptions$ = getBountyDescriptions$(
      typedApi.query.Bounties.BountyDescriptions.getEntries,
      typedApi.query.Bounties.BountyDescriptions.getValues,
      bountyKeyChanges$
    );
    const bountyIds$ = bountyKeyChanges$.pipe(
      utils.toKeySet(),
      rxjs.map((set) => [...set])
    );
    const getEnhancedBountyById$ = (id) => rxjs.combineLatest([
      getBountyById$(id),
      descriptions$.pipe(
        rxjs.map((r) => r[id] ?? null),
        rxjs.distinctUntilChanged()
      )
    ]).pipe(
      rxjs.map(([bounty, description]) => enhanceBounty(bounty, description, id))
    );
    return {
      bounties$: utils.combineKeys(bountyKeyChanges$, getEnhancedBountyById$),
      getBountyById$: getEnhancedBountyById$,
      bountyIds$
    };
  }
  function getBounty(id, at) {
    return Promise.all([
      typedApi.query.Bounties.Bounties.getValue(id, { at }),
      typedApi.query.Bounties.BountyDescriptions.getValue(id, { at })
    ]).then(
      ([bounty, description]) => bounty ? enhanceBounty(bounty, description ? description.asText() : null, id) : null
    );
  }
  async function getProposedBounty(txEvent) {
    if (!("events" in txEvent)) {
      return null;
    }
    const proposedBountyEvt = typedApi.event.Bounties.BountyProposed.filter(
      txEvent.events
    )[0];
    if (!proposedBountyEvt) {
      return null;
    }
    const id = proposedBountyEvt.index;
    const at = txEvent.type === "finalized" ? void 0 : txEvent.block.hash;
    const bounty = await getBounty(id, at);
    if (!bounty) return null;
    return bounty.type === "Proposed" ? bounty : null;
  }
  function getBounties() {
    return Promise.all([
      typedApi.query.Bounties.Bounties.getEntries(),
      typedApi.query.Bounties.BountyDescriptions.getEntries()
    ]).then(([entries, descriptions]) => {
      const descriptionMap = Object.fromEntries(
        descriptions.map(({ keyArgs, value }) => [keyArgs[0], value.asText()])
      );
      return entries.map(({ keyArgs: [id], value }) => ({ bounty: value, id })).sort((a, b) => a.id - b.id).map(
        ({ bounty, id }) => enhanceBounty(bounty, descriptionMap[id] ?? null, id)
      );
    });
  }
  return {
    watch: watchBounties(),
    getBounties,
    getBounty,
    getProposedBounty
  };
}

function createChildBountiesSdk(typedApi) {
  const enhanceBounty = (bounty, description, id) => {
    const generic = {
      ...bounty,
      type: bounty.status.type,
      id,
      description,
      account: getChildBountyAccount(bounty.parent_bounty, id)
    };
    const idObj = {
      parent_bounty_id: bounty.parent_bounty,
      child_bounty_id: id
    };
    switch (generic.status.type) {
      case "Added":
        return {
          ...generic,
          type: "Added",
          proposeCurator(curator, fee) {
            return typedApi.tx.ChildBounties.propose_curator({
              ...idObj,
              curator: {
                type: "Id",
                value: curator
              },
              fee
            });
          },
          close() {
            return typedApi.tx.ChildBounties.close_child_bounty(idObj);
          }
        };
      case "CuratorProposed":
        return {
          ...generic,
          ...generic.status.value,
          type: "CuratorProposed",
          acceptCuratorRole() {
            return typedApi.tx.ChildBounties.accept_curator(idObj);
          },
          unassignCurator() {
            return typedApi.tx.ChildBounties.unassign_curator(idObj);
          },
          close() {
            return typedApi.tx.ChildBounties.close_child_bounty(idObj);
          }
        };
      case "Active":
        return {
          ...generic,
          type: "Active",
          curator: generic.status.value.curator,
          award(beneficiary) {
            return typedApi.tx.ChildBounties.award_child_bounty({
              ...idObj,
              beneficiary: {
                type: "Id",
                value: beneficiary
              }
            });
          },
          unassignCurator() {
            return typedApi.tx.ChildBounties.unassign_curator(idObj);
          },
          close() {
            return typedApi.tx.ChildBounties.close_child_bounty(idObj);
          }
        };
      case "PendingPayout":
        return {
          ...generic,
          type: "PendingPayout",
          curator: generic.status.value.curator,
          unlockAt: generic.status.value.unlock_at,
          beneficiary: generic.status.value.beneficiary,
          claim() {
            return typedApi.tx.ChildBounties.claim_child_bounty(idObj);
          },
          unassignCurator() {
            return typedApi.tx.ChildBounties.unassign_curator(idObj);
          }
        };
    }
    throw new Error("Unreachable");
  };
  function watchChildBounties(parentId) {
    const [getBountyById$, bountyKeyChanges$] = partitionEntries(
      typedApi.query.ChildBounties.ChildBounties.watchEntries(parentId)
    );
    const descriptions$ = getBountyDescriptions$(
      typedApi.query.ChildBounties.ChildBountyDescriptions.getEntries,
      typedApi.query.ChildBounties.ChildBountyDescriptions.getValues,
      bountyKeyChanges$
    );
    const bountyIds$ = bountyKeyChanges$.pipe(
      utils.toKeySet(),
      rxjs.map((set) => [...set])
    );
    const getEnhancedBountyById$ = (id) => rxjs.combineLatest([
      getBountyById$(id),
      descriptions$.pipe(
        rxjs.map((r) => r[id] ?? null),
        rxjs.distinctUntilChanged()
      )
    ]).pipe(
      rxjs.map(([bounty, description]) => enhanceBounty(bounty, description, id))
    );
    return {
      bounties$: utils.combineKeys(bountyIds$, getEnhancedBountyById$),
      getBountyById$: getEnhancedBountyById$,
      bountyIds$
    };
  }
  function getChildBounty(parentId, id) {
    return Promise.all([
      typedApi.query.ChildBounties.ChildBounties.getValue(parentId, id),
      typedApi.query.ChildBounties.ChildBountyDescriptions.getValue(id).then(
        (r) => r ? r.asText() : null
      )
    ]).then(
      ([bounty, description]) => bounty ? enhanceBounty(bounty, description, id) : null
    );
  }
  return {
    watch: keyedMemo(watchChildBounties, /* @__PURE__ */ new Map()),
    getChildBounty
  };
}

function createConvictionVotingSdk(typedApi) {
  const enhanceVotingFor = ([account, track], votingFor, voteLockingPeriod) => {
    const lock = votingFor.value.prior[1] ? {
      block: votingFor.value.prior[0],
      balance: votingFor.value.prior[1]
    } : null;
    const unlock = () => typedApi.tx.ConvictionVoting.unlock({
      class: track,
      target: {
        type: "Id",
        value: account
      }
    });
    const delegationPower = {
      track,
      ...votingFor.value.delegations
    };
    const trackDetails = {
      track,
      delegationPower,
      lock,
      unlock
    };
    if (votingFor.type === "Casting") {
      const rawVotes = votingFor.value.votes;
      const votes = rawVotes.map(([poll, vote]) => {
        const remove = () => typedApi.tx.ConvictionVoting.remove_vote({
          class: track,
          index: poll
        });
        if (vote.type === "Standard") {
          const convictionValue = vote.value.vote & 127;
          const conviction = {
            type: convictions[convictionValue],
            value: void 0
          };
          const direction = vote.value.vote & 128 ? "aye" : "nay";
          return {
            type: "standard",
            poll,
            direction,
            balance: vote.value.balance,
            conviction,
            getLock(outcome) {
              if (convictionValue && outcome?.side === direction) {
                const end = outcome.ended + convictionLockMultiplier[conviction.type] * voteLockingPeriod;
                return {
                  type: !trackDetails.lock || trackDetails.lock.block === end ? "locked" : trackDetails.lock.block < end ? (
                    // Only `extends` if the outer balance is greater than the vote balance
                    // Because it actually only has an effect if it's extending the lock of a larger amount of tokens
                    trackDetails.lock.balance > vote.value.balance ? "extends" : "locked"
                  ) : (
                    // Same reasoning
                    trackDetails.lock.balance < vote.value.balance ? "extended" : "locked"
                  ),
                  end
                };
              }
              return { type: "free" };
            },
            remove
          };
        }
        const votes2 = {
          aye: vote.value.aye,
          nay: vote.value.nay,
          abstain: vote.value.abstain ?? 0n
        };
        const votesWithValue = Object.entries(votes2).filter(([, v]) => v > 0n);
        if (votesWithValue.length === 1) {
          return {
            type: "standard",
            poll,
            direction: votesWithValue[0][0],
            balance: votesWithValue[0][1],
            conviction: {
              type: "None",
              value: void 0
            },
            getLock() {
              return { type: "free" };
            },
            remove
          };
        }
        return {
          type: "split",
          poll,
          balance: Object.values(votes2).reduce((a, b) => a + b),
          ...votes2,
          getLock() {
            return { type: "free" };
          },
          remove
        };
      });
      return {
        type: "casting",
        votes,
        getUnlockSchedule(outcomes) {
          const unlocks = votes.map((v, i) => {
            const lock2 = v.getLock(outcomes[i]);
            return {
              type: "poll",
              id: v.poll,
              block: lock2.type === "free" ? 0 : lock2.end,
              balance: v.balance
            };
          });
          if (trackDetails.lock) {
            unlocks.push({
              type: "lock",
              id: 0,
              ...trackDetails.lock
            });
          }
          unlocks.sort((a, b) => Number(a.balance - b.balance));
          const result = [];
          let unlocked = 0;
          const getNextGroup = () => {
            if (unlocked >= unlocks.length) return [];
            const start = unlocked;
            const balance = unlocks[unlocked++].balance;
            while (unlocked < result.length && unlocks[unlocked].balance === balance) {
              unlocked++;
            }
            return unlocks.slice(start, unlocked);
          };
          let block = 0;
          while (unlocked < unlocks.length) {
            const group = getNextGroup();
            const nextBalance = unlocks[unlocked]?.balance ?? 0n;
            block = Math.max(block, ...group.map((l) => l.block));
            const balance = group[0].balance - nextBalance;
            result.push({
              block,
              balance,
              unlocks: group.map(
                (v) => v.type === "lock" ? { type: "lock" } : {
                  type: "poll",
                  id: v.id
                }
              )
            });
          }
          return result;
        },
        ...trackDetails
      };
    }
    return {
      type: "delegating",
      target: votingFor.value.target,
      balance: votingFor.value.balance,
      conviction: votingFor.value.conviction,
      lockDuration: convictionLockMultiplier[votingFor.value.conviction.type] * voteLockingPeriod,
      remove() {
        return typedApi.tx.ConvictionVoting.undelegate({
          class: track
        });
      },
      ...trackDetails
    };
  };
  const voteLockingPeriod$ = typedApi.constants.ConvictionVoting.VoteLockingPeriod();
  const votingTrack$ = (account, track) => rxjs.combineLatest([
    typedApi.query.ConvictionVoting.VotingFor.watchValue(account, track),
    voteLockingPeriod$
  ]).pipe(
    rxjs.map(
      ([v, lockPeriod]) => enhanceVotingFor([account, track], v, lockPeriod)
    )
  );
  const watchTracks$ = (account) => {
    const [getTrackById$, trackKeyChanges$] = partitionEntries(
      typedApi.query.ConvictionVoting.VotingFor.watchEntries(account).pipe(
        rxjs.map((v) => ({
          deltas: v.deltas ? {
            deleted: v.deltas.deleted.map((d) => ({
              args: [d.args[1]],
              value: { track: d.args[1], value: d.value }
            })),
            upserted: v.deltas.upserted.map((d) => ({
              args: [d.args[1]],
              value: { track: d.args[1], value: d.value }
            }))
          } : null
        }))
      )
    );
    const trackIds$ = trackKeyChanges$.pipe(
      utils.toKeySet(),
      rxjs.map((set) => [...set])
    );
    const getEnhancedTrackById$ = (id) => rxjs.combineLatest([getTrackById$(id), voteLockingPeriod$]).pipe(
      rxjs.map(
        ([{ track, value }, lockPeriod]) => enhanceVotingFor([account, track], value, lockPeriod)
      )
    );
    return { getTrackById$: getEnhancedTrackById$, trackIds$, trackKeyChanges$ };
  };
  function votingTracks$(account) {
    const { getTrackById$, trackKeyChanges$ } = watchTracks$(account);
    return utils.combineKeys(trackKeyChanges$, getTrackById$).pipe(
      rxjs.map((map2) => Array.from(map2.values()))
    );
  }
  return {
    votingTrack$,
    votingTracks$,
    getVotingTrack(account, track) {
      return rxjs.firstValueFrom(votingTrack$(account, track));
    },
    getVotingTracks(account) {
      return rxjs.firstValueFrom(votingTracks$(account));
    },
    voteSplit(poll, vote) {
      const voteEntries = Object.entries(vote).filter(
        ([, value]) => (value ?? 0n) > 0n
      );
      const hasAbstain = (vote.abstain ?? 0n) > 0n;
      const singleVote = voteEntries.length === 1 ? {
        vote: voteEntries[0][0] === "aye" ? 128 : 0,
        balance: voteEntries[0][1]
      } : null;
      return typedApi.tx.ConvictionVoting.vote({
        poll_index: poll,
        vote: hasAbstain ? {
          type: "SplitAbstain",
          value: {
            abstain: vote.abstain ?? 0n,
            aye: vote.aye ?? 0n,
            nay: vote.nay ?? 0n
          }
        } : singleVote ? {
          type: "Standard",
          value: singleVote
        } : {
          type: "Split",
          value: {
            aye: vote.aye ?? 0n,
            nay: vote.nay ?? 0n
          }
        }
      });
    },
    vote(vote, poll, value, conviction) {
      const voteValue = (vote === "aye" ? 128 : 0) | Math.max(0, convictions.indexOf(conviction ? conviction.type : "None"));
      return typedApi.tx.ConvictionVoting.vote({
        poll_index: poll,
        vote: {
          type: "Standard",
          value: {
            vote: voteValue,
            balance: value
          }
        }
      });
    },
    voteAbstain(poll, value) {
      return typedApi.tx.ConvictionVoting.vote({
        poll_index: poll,
        vote: {
          type: "SplitAbstain",
          value: {
            abstain: value,
            aye: 0n,
            nay: 0n
          }
        }
      });
    }
  };
}
const convictionLockMultiplier = {
  None: 0,
  Locked1x: 1,
  Locked2x: 2,
  Locked3x: 4,
  Locked4x: 8,
  Locked5x: 16,
  Locked6x: 32
};
const convictions = Object.keys(
  convictionLockMultiplier
);

exports.createBountiesSdk = createBountiesSdk;
exports.createChildBountiesSdk = createChildBountiesSdk;
exports.createConvictionVotingSdk = createConvictionVotingSdk;
exports.createReferendaSdk = createReferendaSdk;
exports.kusamaSpenderOrigin = kusamaSpenderOrigin;
exports.polkadotSpenderOrigin = polkadotSpenderOrigin;
//# sourceMappingURL=index.js.map
