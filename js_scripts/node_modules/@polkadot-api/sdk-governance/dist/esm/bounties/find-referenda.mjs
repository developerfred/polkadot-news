import { keyedMemo } from '../util/memo.mjs';

const spenderOrigins = [
  "Treasurer",
  "SmallSpender",
  "MediumSpender",
  "BigSpender",
  "SmallTipper",
  "BigTipper"
];
const getDecodedSpenderReferenda = keyedMemo(
  async (ongoingReferenda) => {
    const spenderReferenda = ongoingReferenda.filter(
      (ref) => ref.origin.type === "Origins" && spenderOrigins.includes(ref.origin.value.type) || ref.origin.type === "system" && ref.origin.value.type === "Root"
    );
    const response = await Promise.all(
      spenderReferenda.map(
        (referendum) => referendum.proposal.decodedCall().then((call) => ({
          referendum,
          call
        })).catch((ex) => {
          console.error(ex);
          return null;
        })
      )
    );
    return response.filter((v) => !!v);
  },
  /* @__PURE__ */ new WeakMap()
);
async function findApprovingReferenda(ongoingReferenda, bountyId) {
  const spenderReferenda = await getDecodedSpenderReferenda(ongoingReferenda);
  return spenderReferenda.filter(
    ({ call }) => findCalls(
      {
        pallet: "Bounties",
        name: "approve_bounty"
      },
      call
    ).some((v) => v?.bounty_id === bountyId)
  ).map(({ referendum }) => referendum);
}
async function findProposingCuratorReferenda(ongoingReferenda, bountyId) {
  const spenderReferenda = await getDecodedSpenderReferenda(ongoingReferenda);
  return spenderReferenda.map(({ call, referendum }) => {
    const proposeCuratorCalls = findCalls(
      {
        pallet: "Bounties",
        name: "propose_curator"
      },
      call
    ).filter(
      (v) => v?.bounty_id === bountyId && typeof v.curator === "object" && typeof v.fee === "bigint"
    ).map((v) => ({
      curator: v.curator,
      fee: v.fee
    }));
    if (!proposeCuratorCalls.length) return null;
    return { referendum, proposeCuratorCalls };
  }).filter((v) => v !== null);
}
const findCalls = (call, obj) => {
  if (typeof obj !== "object") return [];
  if (Array.isArray(obj)) {
    const approves2 = [];
    for (const item of obj) approves2.push(...findCalls(call, item));
    return approves2;
  }
  if (obj?.type === call.pallet && obj?.value?.type === call.name) {
    return [obj.value.value];
  }
  const approves = [];
  for (const key of Object.keys(obj))
    approves.push(...findCalls(call, obj[key]));
  return approves;
};

export { findApprovingReferenda, findCalls, findProposingCuratorReferenda };
//# sourceMappingURL=find-referenda.mjs.map
