import { keyedMemo } from '../util/memo.mjs';
import { partitionEntries } from '../util/watchEntries.mjs';
import { toKeySet, combineKeys } from '@react-rxjs/utils';
import { map, combineLatest, distinctUntilChanged } from 'rxjs';
import { getChildBountyAccount } from './bounty-account.mjs';
import { getBountyDescriptions$ } from './bounty-descriptions.mjs';

function createChildBountiesSdk(typedApi) {
  const enhanceBounty = (bounty, description, id) => {
    const generic = {
      ...bounty,
      type: bounty.status.type,
      id,
      description,
      account: getChildBountyAccount(bounty.parent_bounty, id)
    };
    const idObj = {
      parent_bounty_id: bounty.parent_bounty,
      child_bounty_id: id
    };
    switch (generic.status.type) {
      case "Added":
        return {
          ...generic,
          type: "Added",
          proposeCurator(curator, fee) {
            return typedApi.tx.ChildBounties.propose_curator({
              ...idObj,
              curator: {
                type: "Id",
                value: curator
              },
              fee
            });
          },
          close() {
            return typedApi.tx.ChildBounties.close_child_bounty(idObj);
          }
        };
      case "CuratorProposed":
        return {
          ...generic,
          ...generic.status.value,
          type: "CuratorProposed",
          acceptCuratorRole() {
            return typedApi.tx.ChildBounties.accept_curator(idObj);
          },
          unassignCurator() {
            return typedApi.tx.ChildBounties.unassign_curator(idObj);
          },
          close() {
            return typedApi.tx.ChildBounties.close_child_bounty(idObj);
          }
        };
      case "Active":
        return {
          ...generic,
          type: "Active",
          curator: generic.status.value.curator,
          award(beneficiary) {
            return typedApi.tx.ChildBounties.award_child_bounty({
              ...idObj,
              beneficiary: {
                type: "Id",
                value: beneficiary
              }
            });
          },
          unassignCurator() {
            return typedApi.tx.ChildBounties.unassign_curator(idObj);
          },
          close() {
            return typedApi.tx.ChildBounties.close_child_bounty(idObj);
          }
        };
      case "PendingPayout":
        return {
          ...generic,
          type: "PendingPayout",
          curator: generic.status.value.curator,
          unlockAt: generic.status.value.unlock_at,
          beneficiary: generic.status.value.beneficiary,
          claim() {
            return typedApi.tx.ChildBounties.claim_child_bounty(idObj);
          },
          unassignCurator() {
            return typedApi.tx.ChildBounties.unassign_curator(idObj);
          }
        };
    }
    throw new Error("Unreachable");
  };
  function watchChildBounties(parentId) {
    const [getBountyById$, bountyKeyChanges$] = partitionEntries(
      typedApi.query.ChildBounties.ChildBounties.watchEntries(parentId)
    );
    const descriptions$ = getBountyDescriptions$(
      typedApi.query.ChildBounties.ChildBountyDescriptions.getEntries,
      typedApi.query.ChildBounties.ChildBountyDescriptions.getValues,
      bountyKeyChanges$
    );
    const bountyIds$ = bountyKeyChanges$.pipe(
      toKeySet(),
      map((set) => [...set])
    );
    const getEnhancedBountyById$ = (id) => combineLatest([
      getBountyById$(id),
      descriptions$.pipe(
        map((r) => r[id] ?? null),
        distinctUntilChanged()
      )
    ]).pipe(
      map(([bounty, description]) => enhanceBounty(bounty, description, id))
    );
    return {
      bounties$: combineKeys(bountyIds$, getEnhancedBountyById$),
      getBountyById$: getEnhancedBountyById$,
      bountyIds$
    };
  }
  function getChildBounty(parentId, id) {
    return Promise.all([
      typedApi.query.ChildBounties.ChildBounties.getValue(parentId, id),
      typedApi.query.ChildBounties.ChildBountyDescriptions.getValue(id).then(
        (r) => r ? r.asText() : null
      )
    ]).then(
      ([bounty, description]) => bounty ? enhanceBounty(bounty, description, id) : null
    );
  }
  return {
    watch: keyedMemo(watchChildBounties, /* @__PURE__ */ new Map()),
    getChildBounty
  };
}

export { createChildBountiesSdk };
//# sourceMappingURL=child-bounties-sdk.mjs.map
