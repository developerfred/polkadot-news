import { partitionEntries } from '../util/watchEntries.mjs';
import { blake2b } from '@noble/hashes/blake2b';
import { combineKeys, toKeySet } from '@react-rxjs/utils';
import { Binary } from 'polkadot-api';
import { map } from 'rxjs';
import { getPreimageResolver } from '../preimages.mjs';
import { polkadotSpenderOrigin, originToTrack } from './chainConfig.mjs';
import { trackFetcher, BIG_BILLION } from './track.mjs';

const MAX_INLINE_SIZE = 128;
const defaultConfig = {
  spenderOrigin: polkadotSpenderOrigin
};
function createReferendaSdk(typedApi, config) {
  const { spenderOrigin } = { ...defaultConfig, ...config };
  const resolvePreimage = getPreimageResolver(
    typedApi.query.Preimage.PreimageFor.getValues
  );
  const getTrack = trackFetcher(typedApi);
  function enhanceOngoingReferendum(id, referendum) {
    const resolveProposal = () => resolvePreimage(referendum.proposal);
    async function getConfirmationStart() {
      const totalVotes = referendum.tally.ayes + referendum.tally.nays;
      if (totalVotes == 0n || !referendum.deciding) {
        return null;
      }
      if (referendum.deciding.confirming) {
        return referendum.deciding.confirming;
      }
      const [track, totalIssuance, inactiveIssuance] = await Promise.all([
        getTrack(referendum.track),
        typedApi.query.Balances.TotalIssuance.getValue(),
        typedApi.query.Balances.InactiveIssuance.getValue()
      ]);
      if (!track) return null;
      const approvals = BIG_BILLION * referendum.tally.ayes / totalVotes;
      const support = BIG_BILLION * referendum.tally.support / (totalIssuance - inactiveIssuance);
      const approvalBlock = track.minApproval.getBlock(approvals);
      const supportBlock = track.minSupport.getBlock(support);
      const block = Math.max(approvalBlock, supportBlock);
      if (block === Number.POSITIVE_INFINITY) return null;
      return referendum.deciding.since + block;
    }
    async function getConfirmationEnd() {
      if (!referendum.deciding) return null;
      const track = await getTrack(referendum.track);
      if (!track) return null;
      const confirmationStart = referendum.deciding.confirming ?? await getConfirmationStart();
      if (!confirmationStart) return null;
      return confirmationStart + track.confirm_period;
    }
    return {
      ...referendum,
      type: "Ongoing",
      id,
      proposal: {
        rawValue: referendum.proposal,
        resolve: resolveProposal,
        decodedCall: async () => {
          const proposal = await resolveProposal();
          const token = await typedApi.compatibilityToken;
          return typedApi.txFromCallData(proposal, token).decodedCall;
        }
      },
      async getDetails(subscanApiKey) {
        const result = await fetch(
          "https://polkadot.api.subscan.io/api/scan/referenda/referendum",
          {
            method: "POST",
            body: JSON.stringify({
              referendum_index: id
            }),
            headers: {
              "x-api-key": subscanApiKey
            }
          }
        ).then((r) => r.json());
        return {
          title: result.data.title
        };
      },
      getConfirmationStart,
      getConfirmationEnd,
      async getTrack() {
        const track = await getTrack(referendum.track);
        if (!track) {
          throw new Error("Track not found");
        }
        return track;
      },
      outcome: null,
      async getExpectedOutcome() {
        const confirmationEnd = await getConfirmationEnd();
        return confirmationEnd ? {
          side: referendum.tally.ayes > referendum.tally.nays ? "aye" : "nay",
          ended: confirmationEnd
        } : null;
      }
    };
  }
  function enhanceReferendumInfo(id, info) {
    if (info.type === "Ongoing") return enhanceOngoingReferendum(id, info.value);
    if (info.type === "Killed")
      return {
        type: "Killed",
        block: info.value,
        submission_deposit: void 0,
        decision_deposit: void 0,
        outcome: null
      };
    const [block, submission_deposit, decision_deposit] = info.value;
    return {
      type: info.type,
      block,
      submission_deposit,
      decision_deposit,
      outcome: info.type === "Approved" ? { side: "aye", ended: block } : info.type === "Rejected" ? {
        side: "nay",
        ended: block
      } : null
    };
  }
  async function getReferenda() {
    const entries = await typedApi.query.Referenda.ReferendumInfoFor.getEntries();
    return entries.map(
      ({ keyArgs: [id], value: info }) => enhanceReferendumInfo(id, info)
    );
  }
  async function getReferendum(id) {
    const referendum = await typedApi.query.Referenda.ReferendumInfoFor.getValue(id);
    return referendum ? enhanceReferendumInfo(id, referendum) : null;
  }
  const [rawReferendumById$, referendaKeyChange$] = partitionEntries(
    typedApi.query.Referenda.ReferendumInfoFor.watchEntries()
  );
  const getReferendumById$ = (id) => rawReferendumById$(id).pipe(
    map((entry) => enhanceReferendumInfo(id, entry))
  );
  const referenda$ = combineKeys(referendaKeyChange$, getReferendumById$);
  const referendaIds$ = referendaKeyChange$.pipe(
    toKeySet(),
    map((set) => [...set])
  );
  const getSpenderTrack = (value) => {
    const spenderOriginType = spenderOrigin(value);
    const origin = spenderOriginType ? {
      type: "Origins",
      value: {
        type: spenderOriginType,
        value: void 0
      }
    } : {
      type: "system",
      value: { type: "Root", value: void 0 }
    };
    return {
      origin,
      track: getTrack(
        spenderOriginType ? originToTrack[spenderOriginType] : "root"
      ).then((r) => {
        if (!r) {
          throw new Error(`Track ${spenderOriginType ?? "root"} not found`);
        }
        return r;
      })
    };
  };
  const createReferenda = (origin, proposal, options) => {
    const enactment_moment = options?.enactment ?? {
      type: "After",
      value: 0
    };
    if (proposal.asBytes().length <= MAX_INLINE_SIZE) {
      return typedApi.tx.Referenda.submit({
        enactment_moment,
        proposal: {
          type: "Inline",
          value: proposal
        },
        proposal_origin: origin
      });
    }
    const hash = blake2b(proposal.asBytes());
    return typedApi.tx.Utility.batch_all({
      calls: [
        // Expose the deposit required for the preimage
        // maybe as part of fee + deposit
        typedApi.tx.Preimage.note_preimage({
          bytes: proposal
        }).decodedCall,
        typedApi.tx.Referenda.submit({
          enactment_moment,
          proposal: {
            type: "Lookup",
            value: {
              hash: Binary.fromBytes(hash),
              len: proposal.asBytes().length
            }
          },
          proposal_origin: origin
        }).decodedCall
      ]
    });
  };
  const createSpenderReferenda = (callData, value) => {
    const spenderTrack = getSpenderTrack(value);
    return createReferenda(spenderTrack.origin, callData);
  };
  const getSubmittedReferendum = (txEvent) => "events" in txEvent ? typedApi.event.Referenda.Submitted.filter(txEvent.events)[0] ?? null : null;
  return {
    watch: {
      referenda$,
      getReferendumById$,
      referendaIds$
    },
    getReferenda,
    getReferendum,
    getSpenderTrack,
    getTrack,
    createReferenda,
    createSpenderReferenda,
    getSubmittedReferendum
  };
}

export { createReferendaSdk };
//# sourceMappingURL=referenda-sdk.mjs.map
