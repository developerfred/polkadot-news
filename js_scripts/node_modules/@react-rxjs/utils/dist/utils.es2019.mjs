// src/combineKeys.ts
import { Observable } from "rxjs";
var combineKeys = (keys$, getInner$) => new Observable((observer) => {
  const innerSubscriptions = /* @__PURE__ */ new Map();
  let changes = /* @__PURE__ */ new Set();
  const currentValue = /* @__PURE__ */ new Map();
  let updatingSource = false;
  let isPristine = true;
  const next = () => {
    if (!updatingSource) {
      const result = Object.assign(currentValue, {
        changes
      });
      changes = /* @__PURE__ */ new Set();
      isPristine = false;
      observer.next(result);
    }
  };
  const subscription = keys$.subscribe((nextKeysArr) => {
    updatingSource = true;
    const keys = new Set(inputIsKeyChanges(nextKeysArr) ? nextKeysArr.keys : nextKeysArr);
    if (inputIsKeyChanges(nextKeysArr)) {
      if (nextKeysArr.type === "remove") {
        keys.forEach((key) => {
          const sub = innerSubscriptions.get(key);
          if (!sub)
            return;
          sub.unsubscribe();
          innerSubscriptions.delete(key);
          if (currentValue.has(key)) {
            changes.add(key);
            currentValue.delete(key);
          }
        });
        keys.clear();
      }
    } else {
      innerSubscriptions.forEach((sub, key) => {
        if (!keys.has(key)) {
          sub.unsubscribe();
          innerSubscriptions.delete(key);
          if (currentValue.has(key)) {
            changes.add(key);
            currentValue.delete(key);
          }
        } else {
          keys.delete(key);
        }
      });
    }
    keys.forEach((key) => {
      innerSubscriptions.set(key, getInner$(key).subscribe((x) => {
        if (!currentValue.has(key) || currentValue.get(key) !== x) {
          changes.add(key);
          currentValue.set(key, x);
          next();
        }
      }, (e) => {
        observer.error(e);
      }));
    });
    updatingSource = false;
    if (changes.size || isPristine && !keys.size)
      next();
  }, (e) => {
    observer.error(e);
  }, () => {
    observer.complete();
  });
  return () => {
    subscription.unsubscribe();
    innerSubscriptions.forEach((sub) => {
      sub.unsubscribe();
    });
  };
});
function inputIsKeyChanges(input) {
  return "type" in input && "keys" in input;
}

// src/createSignal.ts
import { identity, Subject } from "rxjs";
function createSignal(mapper = identity) {
  const subject = new Subject();
  return [subject.asObservable(), (...args) => subject.next(mapper(...args))];
}

// src/createKeyedSignal.ts
import { Observable as Observable3 } from "rxjs";
function createKeyedSignal(keySelector, mapper) {
  const observersMap = /* @__PURE__ */ new Map();
  return [
    (key) => {
      const res = new Observable3((observer) => {
        if (!observersMap.has(key)) {
          observersMap.set(key, /* @__PURE__ */ new Set());
        }
        const set = observersMap.get(key);
        set.add(observer);
        return () => {
          set.delete(observer);
          if (set.size === 0) {
            observersMap.delete(key);
          }
        };
      });
      res.key = key;
      return res;
    },
    (...args) => {
      var _a;
      const payload = mapper ? mapper(...args) : args.length === 2 ? args[1] : args[0];
      const key = keySelector ? keySelector(payload) : args[0];
      (_a = observersMap.get(key)) == null ? void 0 : _a.forEach((o) => {
        o.next(payload);
      });
    }
  ];
}

// src/mergeWithKey.ts
import { merge, from } from "rxjs";
import { map } from "rxjs/operators";
var mergeWithKey = (input, ...optionalArgs) => merge(...Object.entries(input).map(([type, stream]) => from(stream).pipe(map((payload) => ({ type, payload })))).concat(optionalArgs));

// src/partitionByKey.ts
import { shareLatest } from "@react-rxjs/core";
import {
  identity as identity2,
  noop,
  Observable as Observable5,
  Subject as Subject2,
  Subscription as Subscription2
} from "rxjs";
import { map as map2 } from "rxjs/operators";
function partitionByKey(stream, keySelector, streamSelector) {
  const groupedObservables$ = new Observable5((subscriber) => {
    const groups = /* @__PURE__ */ new Map();
    let sourceCompleted = false;
    const finalize = (type) => (...args) => {
      sourceCompleted = true;
      if (groups.size) {
        groups.forEach((g) => g.source[type](...args));
      } else {
        subscriber[type](...args);
      }
    };
    const sub2 = stream.subscribe((x) => {
      const key = keySelector(x);
      if (groups.has(key))
        return groups.get(key).source.next(x);
      let pendingFirstAdd = true;
      const emitFirstAdd = () => {
        if (pendingFirstAdd) {
          pendingFirstAdd = false;
          subscriber.next({
            groups,
            changes: {
              type: "add",
              keys: [key]
            }
          });
        }
      };
      const subject = new Subject2();
      let pendingFirstVal = true;
      const emitFirstValue = () => {
        if (pendingFirstVal) {
          pendingFirstVal = false;
          subject.next(x);
        }
      };
      const shared$ = shareLatest()((streamSelector || identity2)(subject, key));
      const res = new Observable5((observer) => {
        incRefcount();
        const subscription = shared$.subscribe(observer);
        subscription.add(decRefcount);
        emitFirstValue();
        return subscription;
      });
      res.key = key;
      const innerGroup = {
        source: subject,
        observable: res,
        subscription: new Subscription2()
      };
      groups.set(key, innerGroup);
      innerGroup.subscription = shared$.subscribe(noop, (e) => subscriber.error(e), () => {
        groups.delete(key);
        emitFirstAdd();
        subscriber.next({
          groups,
          changes: {
            type: "remove",
            keys: [key]
          }
        });
        if (groups.size === 0 && sourceCompleted) {
          subscriber.complete();
        }
      });
      emitFirstAdd();
      emitFirstValue();
    }, finalize("error"), finalize("complete"));
    return () => {
      sub2.unsubscribe();
      groups.forEach((g) => {
        g.source.unsubscribe();
        g.subscription.unsubscribe();
      });
    };
  }).pipe(shareLatest());
  let refCount = 0;
  let sub;
  function incRefcount() {
    refCount++;
    if (refCount === 1) {
      sub = groupedObservables$.subscribe();
    }
  }
  function decRefcount() {
    refCount--;
    if (refCount === 0) {
      sub == null ? void 0 : sub.unsubscribe();
    }
  }
  return [
    (key) => getGroupedObservable(groupedObservables$.pipe(map2(({ groups }) => groups)), key),
    groupedObservables$.pipe(map2((m, i) => {
      if (i === 0) {
        return {
          type: "add",
          keys: m.groups.keys()
        };
      }
      return m.changes;
    }))
  ];
}
var getGroupedObservable = (source$, key) => {
  const result = new Observable5((observer) => {
    let innerSub;
    let outerSub;
    let foundSynchronously = false;
    outerSub = source$.subscribe((n) => {
      const innerGroup = n.get(key);
      if (innerGroup && !innerSub) {
        innerSub = innerGroup.observable.subscribe(observer);
        outerSub == null ? void 0 : outerSub.unsubscribe();
        foundSynchronously = true;
      }
    }, (e) => {
      observer.error(e);
    }, () => {
      observer.complete();
    });
    if (foundSynchronously) {
      outerSub.unsubscribe();
      outerSub = void 0;
    }
    return () => {
      innerSub == null ? void 0 : innerSub.unsubscribe();
      outerSub == null ? void 0 : outerSub.unsubscribe();
    };
  });
  result.key = key;
  return result;
};

// src/toKeySet.ts
import { Observable as Observable6 } from "rxjs";
function toKeySet() {
  return (source$) => new Observable6((observer) => {
    const result = /* @__PURE__ */ new Set();
    let pristine = true;
    const subscription = source$.subscribe({
      next({ type, keys }) {
        const action = type === "add" ? type : "delete";
        for (let k of keys) {
          result[action](k);
        }
        observer.next(result);
        pristine = false;
      },
      error(e) {
        observer.error(e);
      },
      complete() {
        observer.complete();
      }
    });
    if (pristine)
      observer.next(result);
    return subscription;
  });
}

// src/suspend.ts
import { from as from2 } from "rxjs";
import { SUSPENSE } from "@react-rxjs/core";

// src/internal-utils.ts
import { Observable as Observable7 } from "rxjs";
var defaultStart = (value) => (source$) => new Observable7((observer) => {
  let emitted = false;
  const subscription = source$.subscribe((x) => {
    emitted = true;
    observer.next(x);
  }, (e) => {
    observer.error(e);
  }, () => {
    observer.complete();
  });
  if (!emitted) {
    observer.next(value);
  }
  return subscription;
});

// src/suspend.ts
var suspend = (source$) => defaultStart(SUSPENSE)(from2(source$));

// src/suspended.ts
var suspended = () => suspend;

// src/switchMapSuspended.ts
import { pipe } from "rxjs";
import { switchMap } from "rxjs/operators";
var switchMapSuspended = (project) => pipe(switchMap((x, index) => suspend(project(x, index))));

// src/selfDependent.ts
import {
  Subject as Subject3,
  BehaviorSubject
} from "rxjs";
import { switchAll, tap } from "rxjs/operators";
var selfDependent = () => {
  const activeSubject = new BehaviorSubject(new Subject3());
  return [
    activeSubject.pipe(switchAll()),
    () => tap({
      next: (v) => activeSubject.value.next(v),
      error: (e) => {
        activeSubject.value.error(e);
        activeSubject.next(new Subject3());
      },
      complete: () => {
        activeSubject.value.complete();
        activeSubject.next(new Subject3());
      }
    })
  ];
};
var selfDependant = selfDependent;

// src/contextBinder.ts
import { bind } from "@react-rxjs/core";
var execSelf = (fn) => fn();
function contextBinder(...args) {
  const useArgs = () => args.map(execSelf);
  return function() {
    const [hook, getter] = bind.apply(null, arguments);
    return [(...args2) => hook(...useArgs(), ...args2), getter];
  };
}

// src/createListener.ts
function createListener(...args) {
  return createSignal(...args);
}
export {
  combineKeys,
  contextBinder,
  createKeyedSignal,
  createListener,
  createSignal,
  mergeWithKey,
  partitionByKey,
  selfDependant,
  selfDependent,
  suspend,
  suspended,
  switchMapSuspended,
  toKeySet
};
//# sourceMappingURL=utils.es2019.mjs.map
