import { publish, mergeMap, takeUntil, takeLast, endWith, scan, map, skipWhile, distinctUntilChanged, ignoreElements, startWith, shareReplay, switchMap, tap } from 'rxjs/operators';
import { defer, Observable, Subject, merge, from, ReplaySubject } from 'rxjs';
import { shareLatest, SUSPENSE } from '@react-rxjs/core';

var defaultStart = function defaultStart(value) {
  return function (source$) {
    return new Observable(function (observer) {
      var emitted = false;
      var subscription = source$.subscribe(function (x) {
        emitted = true;
        observer.next(x);
      }, function (e) {
        return observer.error(e);
      }, function () {
        return observer.complete();
      });

      if (!emitted) {
        observer.next(value);
      }

      return subscription;
    });
  };
};
var scanWithDefaultValue = function scanWithDefaultValue(accumulator, getSeed) {
  return function (source) {
    return defer(function () {
      var seed = getSeed();
      return source.pipe(scan(accumulator, seed), defaultStart(seed));
    });
  };
};
var set = "s";
var del = "d";
var complete = "c";
var collector = function collector(source, enhancer) {
  return source.pipe(publish(function (x) {
    return x.pipe(mergeMap(enhancer), takeUntil(takeLast(1)(x)));
  }), endWith({
    t: complete
  }), scanWithDefaultValue(function (acc, val) {
    if (val.t === set) {
      acc.set(val.k, val.v);
    } else if (val.t === del) {
      acc["delete"](val.k);
    } else {
      acc.clear();
    }

    return acc;
  }, function () {
    return new Map();
  }), shareLatest());
};

/**
 * A pipeable operator that collects all the GroupedObservables emitted by
 * the source and emits a Map with the latest values of the inner observables.
 */

var collectValues = function collectValues() {
  return function (source$) {
    return collector(source$, function (inner$) {
      return inner$.pipe(map(function (v) {
        return {
          t: set,
          k: inner$.key,
          v: v
        };
      }), endWith({
        t: del,
        k: inner$.key
      }));
    });
  };
};

var defaultFilter = function defaultFilter(source$) {
  return source$.pipe(ignoreElements(), startWith(true), endWith(false));
};
/**
 * A pipeable operator that collects all the GroupedObservables emitted by
 * the source and emits a Map with the active inner observables
 *
 * @param filter? A function that receives the inner Observable and returns an
 * Observable of boolean values, which indicates whether the inner observable
 * should be collected.
 */


var collect = function collect(filter) {
  var enhancer = filter ? function (source$) {
    return filter(source$).pipe(endWith(false), skipWhile(function (x) {
      return !x;
    }), distinctUntilChanged());
  } : defaultFilter;
  return function (source$) {
    return collector(source$, function (o) {
      return map(function (x) {
        return {
          t: x ? set : del,
          k: o.key,
          v: o
        };
      })(enhancer(o));
    });
  };
};

var defaultMapper = function defaultMapper() {};

function createListener(mapper) {
  if (mapper === void 0) {
    mapper = defaultMapper;
  }

  var subject = new Subject();
  return [subject.asObservable(), function () {
    return subject.next(mapper.apply(void 0, arguments));
  }];
}

/**
 * Emits the values from all the streams of the provided object, in a result
 * which provides the key of the stream of that emission.
 *
 * @param input object of streams
 */

var mergeWithKey = function mergeWithKey(input) {
  for (var _len = arguments.length, optionalArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    optionalArgs[_key - 1] = arguments[_key];
  }

  return merge.apply(void 0, Object.entries(input).map(function (_ref) {
    var type = _ref[0],
        stream = _ref[1];
    return from(stream).pipe(map(function (payload) {
      return {
        type: type,
        payload: payload
      };
    }));
  }).concat(optionalArgs));
};

var emptyError = {};
function split(keySelector, streamSelector) {
  return function (stream) {
    return new Observable(function (subscriber) {
      var groups = new Map();
      var error = emptyError;
      var sub = stream.subscribe(function (x) {
        var key = keySelector(x);

        if (groups.has(key)) {
          return groups.get(key).next(x);
        }

        var subject = streamSelector ? new Subject() : new ReplaySubject(1);
        groups.set(key, subject);
        var res = streamSelector ? streamSelector(subject, key).pipe(shareReplay(1)) : subject.asObservable();
        res.key = key;

        var onFinish = function onFinish() {
          return groups["delete"](key);
        };

        res.subscribe(undefined, onFinish, onFinish);
        subject.next(x);
        subscriber.next(res);
      }, function (e) {
        subscriber.error(error = e);
      }, function () {
        subscriber.complete();
      });
      return function () {
        sub.unsubscribe();
        groups.forEach(error === emptyError ? function (g) {
          return g.complete();
        } : function (g) {
          return g.error(error);
        });
      };
    });
  };
}

/**
 * A RxJS creation operator that prepends a SUSPENSE on the source observable.
 *
 * @param source$ Source observable
 */

var suspend = function suspend(source$) {
  return from(source$).pipe(startWith(SUSPENSE));
};

/**
 * A RxJS pipeable operator that prepends a SUSPENSE on the source observable.
 */

var suspended = function suspended() {
  return suspend;
};

/**
 * Same behaviour as rxjs' `switchMap`, but prepending every new event with
 * SUSPENSE.
 *
 * @param fn Projection function
 */

var switchMapSuspended = function switchMapSuspended(project) {
  return function (src$) {
    return src$.pipe(switchMap(function (x, index) {
      return suspend(project(x, index));
    }));
  };
};

/**
 * A creation operator that helps at creating observables that have circular
 * dependencies
 *
 * @returns [1, 2]
 * 1. The inner subject as an Observable
 * 2. A pipable operator that taps into the inner Subject
 */

var selfDependant = function selfDependant() {
  var mirrored$ = new Subject();
  return [mirrored$.asObservable(), function () {
    return tap(mirrored$);
  }];
};

export { collect, collectValues, createListener, mergeWithKey, selfDependant, split, suspend, suspended, switchMapSuspended };
//# sourceMappingURL=utils.esm.js.map
