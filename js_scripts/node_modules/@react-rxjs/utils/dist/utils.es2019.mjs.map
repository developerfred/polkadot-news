{
  "version": 3,
  "sources": ["../src/combineKeys.ts", "../src/createSignal.ts", "../src/createKeyedSignal.ts", "../src/mergeWithKey.ts", "../src/partitionByKey.ts", "../src/toKeySet.ts", "../src/suspend.ts", "../src/internal-utils.ts", "../src/suspended.ts", "../src/switchMapSuspended.ts", "../src/selfDependent.ts", "../src/contextBinder.ts", "../src/createListener.ts"],
  "sourcesContent": ["import { KeyChanges } from \"./partitionByKey\"\nimport { Observable, Subscription } from \"rxjs\"\n\nexport interface MapWithChanges<K, V> extends Map<K, V> {\n  changes: Set<K>\n}\n\n/**\n * Creates a stream that combines the result of the streams from each key of the input stream.\n *\n * @param keys$ Stream of the list of keys to subscribe to.\n * @param getInner$ Function that returns the stream for each key.\n * @returns An stream with a map containing the latest value from the stream of each key.\n */\nexport const combineKeys = <K, T>(\n  keys$: Observable<Iterable<K> | KeyChanges<K>>,\n  getInner$: (key: K) => Observable<T>,\n): Observable<MapWithChanges<K, T>> =>\n  new Observable((observer) => {\n    const innerSubscriptions = new Map<K, Subscription>()\n    let changes = new Set<K>()\n    const currentValue = new Map<K, T>()\n    let updatingSource = false\n    let isPristine = true\n\n    const next = () => {\n      if (!updatingSource) {\n        const result = Object.assign(currentValue, {\n          changes,\n        })\n        changes = new Set<K>()\n        isPristine = false\n        observer.next(result)\n      }\n    }\n\n    const subscription = keys$.subscribe(\n      (nextKeysArr) => {\n        updatingSource = true\n\n        const keys = new Set(\n          inputIsKeyChanges(nextKeysArr) ? nextKeysArr.keys : nextKeysArr,\n        )\n\n        if (inputIsKeyChanges(nextKeysArr)) {\n          if (nextKeysArr.type === \"remove\") {\n            keys.forEach((key) => {\n              const sub = innerSubscriptions.get(key)\n              if (!sub) return\n              sub.unsubscribe()\n              innerSubscriptions.delete(key)\n              if (currentValue.has(key)) {\n                changes.add(key)\n                currentValue.delete(key)\n              }\n            })\n            // Keys after this block is the list of keys to add. Clear it.\n            keys.clear()\n          }\n        } else {\n          innerSubscriptions.forEach((sub, key) => {\n            if (!keys.has(key)) {\n              sub.unsubscribe()\n              innerSubscriptions.delete(key)\n              if (currentValue.has(key)) {\n                changes.add(key)\n                currentValue.delete(key)\n              }\n            } else {\n              keys.delete(key)\n            }\n          })\n        }\n\n        keys.forEach((key) => {\n          innerSubscriptions.set(\n            key,\n            getInner$(key).subscribe(\n              (x) => {\n                if (!currentValue.has(key) || currentValue.get(key) !== x) {\n                  changes.add(key)\n                  currentValue.set(key, x)\n                  next()\n                }\n              },\n              (e) => {\n                observer.error(e)\n              },\n            ),\n          )\n        })\n\n        updatingSource = false\n        // If there are no changes but the nextKeys are an empty iterator\n        // and we have never emitted before, that means that the first\n        // value that keys$ has emitted is an empty iterator, therefore\n        // we should emit an empy Map\n        if (changes.size || (isPristine && !keys.size)) next()\n      },\n      (e) => {\n        observer.error(e)\n      },\n      () => {\n        observer.complete()\n      },\n    )\n\n    return () => {\n      subscription.unsubscribe()\n      innerSubscriptions.forEach((sub) => {\n        sub.unsubscribe()\n      })\n    }\n  })\n\nfunction inputIsKeyChanges<K>(\n  input: Iterable<K> | KeyChanges<K>,\n): input is KeyChanges<K> {\n  return \"type\" in input && \"keys\" in input\n}\n", "import { identity, Observable, Subject } from \"rxjs\"\n\n/**\n * Creates a signal. It's sugar for splitting the Observer and the Observable of a signal.\n *\n * @param mapper a mapper function, for mapping the arguments of the emitter function into\n * the value of the Observable.\n * @returns [1, 2]\n * 1. The Observable<T>\n * 2. The emitter function.\n */\nexport function createSignal<A extends unknown[], T>(\n  mapper: (...args: A) => T,\n): [Observable<T>, (...args: A) => void]\n\n/**\n * Creates a void signal. It's sugar for splitting the Observer and the Observable of a signal.\n *\n * @returns [1, 2]\n * 1. The Observable<void>\n * 2. The emitter function.\n */\nexport function createSignal(): [Observable<void>, () => void]\n\n/**\n * Creates a signal. It's sugar for splitting the Observer and the Observable of a signal.\n *\n * @returns [1, 2]\n * 1. The Observable<T>\n * 2. The emitter function.\n */\nexport function createSignal<T>(): [Observable<T>, (payload: T) => void]\n\nexport function createSignal<A extends unknown[], T>(\n  mapper: (...args: A) => T = identity as any,\n): [Observable<T>, (...args: A) => void] {\n  const subject = new Subject<T>()\n  return [subject.asObservable(), (...args: A) => subject.next(mapper(...args))]\n}\n", "import { GroupedObservable, Observable, Observer } from \"rxjs\"\n\n/**\n * Creates a \"keyed\" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.\n *\n * @returns [1, 2]\n * 1. The getter function that returns the GroupedObservable<T, T>\n * 2. The emitter function.\n */\nexport function createKeyedSignal<T>(): [\n  (key: T) => GroupedObservable<T, T>,\n  (key: T) => void,\n]\n\n/**\n * Creates a \"keyed\" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.\n *\n * @param keySelector a function that extracts the key from the emitted value\n * @returns [1, 2]\n * 1. The getter function that returns the GroupedObservable<K, T>\n * 2. The emitter function.\n */\nexport function createKeyedSignal<K, T>(): [\n  (key: K) => GroupedObservable<K, T>,\n  (key: K, value: T) => void,\n]\n\n/**\n * Creates a \"keyed\" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.\n *\n * @param keySelector a function that extracts the key from the emitted value\n * @returns [1, 2]\n * 1. The getter function that returns the GroupedObservable<K, T>\n * 2. The emitter function.\n */\nexport function createKeyedSignal<K, T>(\n  keySelector: (signal: T) => K,\n): [(key: K) => GroupedObservable<K, T>, (signal: T) => void]\n\n/**\n * Creates a \"keyed\" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.\n *\n * @param keySelector a function that extracts the key from the emitted value\n * @param mapper a function that maps the arguments of the emitter function to the value of the GroupedObservable\n * @returns [1, 2]\n * 1. The getter function that returns the GroupedObservable<K, T>\n * 2. The emitter function (...args: any[]) => T.\n */\nexport function createKeyedSignal<K, T, A extends any[]>(\n  keySelector: (signal: T) => K,\n  mapper: (...args: A) => T,\n): [(key: K) => GroupedObservable<K, T>, (...args: A) => void]\n\nexport function createKeyedSignal<K, T, A extends any[]>(\n  keySelector?: (signal: T) => K,\n  mapper?: (...args: A) => T,\n): [(key: K) => GroupedObservable<K, T>, (...args: A) => void] {\n  const observersMap = new Map<K, Set<Observer<T>>>()\n\n  return [\n    (key: K) => {\n      const res = new Observable<T>((observer) => {\n        if (!observersMap.has(key)) {\n          observersMap.set(key, new Set())\n        }\n        const set = observersMap.get(key)!\n        set.add(observer)\n        return () => {\n          set.delete(observer)\n          if (set.size === 0) {\n            observersMap.delete(key)\n          }\n        }\n      }) as GroupedObservable<K, T>\n      ;(res as any).key = key\n      return res\n    },\n    (...args: A) => {\n      const payload = mapper\n        ? mapper(...args)\n        : args.length === 2\n        ? args[1]\n        : args[0]\n      const key = keySelector ? keySelector(payload) : args[0]\n      observersMap.get(key)?.forEach((o) => {\n        o.next(payload)\n      })\n    },\n  ]\n}\n", "import { merge, Observable, ObservableInput, from, SchedulerLike } from \"rxjs\"\nimport { map } from \"rxjs/operators\"\n\n/**\n * Emits the values from all the streams of the provided object, in a result\n * which provides the key of the stream of that emission.\n *\n * @param input object of streams\n */\nexport const mergeWithKey: <\n  O extends { [P in keyof any]: ObservableInput<any> },\n  OT extends {\n    [K in keyof O]: O[K] extends ObservableInput<infer V>\n      ? { type: K; payload: V }\n      : unknown\n  },\n>(\n  x: O,\n  concurrent?: number,\n  scheduler?: SchedulerLike,\n) => Observable<OT[keyof O]> = (input, ...optionalArgs) =>\n  merge<any[]>(\n    ...(Object.entries(input)\n      .map(\n        ([type, stream]) =>\n          from(stream).pipe(\n            map((payload) => ({ type, payload } as any)),\n          ) as any,\n      )\n      .concat(optionalArgs) as any[]),\n  )\n", "import { shareLatest } from \"@react-rxjs/core\"\nimport {\n  GroupedObservable,\n  identity,\n  noop,\n  Observable,\n  Subject,\n  Subscription,\n} from \"rxjs\"\nimport { map } from \"rxjs/operators\"\n\nexport interface KeyChanges<K> {\n  type: \"add\" | \"remove\"\n  keys: Iterable<K>\n}\n\n/**\n * Groups the elements from the source stream by using `keySelector`, returning\n * a stream of the active keys, and a function to get the stream of a specific group\n *\n * @param stream Input stream\n * @param keySelector Function that specifies the key for each element in `stream`\n * @param streamSelector Function to apply to each resulting group\n * @returns [1, 2]\n * 1. A function that accepts a key and returns the stream for the group of that key.\n * 2. A stream of KeyChanges, an object that describes what keys have been added or deleted.\n */\nexport function partitionByKey<T, K, R>(\n  stream: Observable<T>,\n  keySelector: (value: T) => K,\n  streamSelector: (grouped: Observable<T>, key: K) => Observable<R>,\n): [(key: K) => GroupedObservable<K, R>, Observable<KeyChanges<K>>]\n\n/**\n * Groups the elements from the source stream by using `keySelector`, returning\n * a stream of the active keys, and a function to get the stream of a specific group\n *\n * @param stream Input stream\n * @param keySelector Function that specifies the key for each element in `stream`\n * @returns [1, 2]\n * 1. A function that accepts a key and returns the stream for the group of that key.\n * 2. A stream of KeyChanges, an object that describes what keys have been added or deleted.\n */\nexport function partitionByKey<T, K>(\n  stream: Observable<T>,\n  keySelector: (value: T) => K,\n): [(key: K) => GroupedObservable<K, T>, Observable<KeyChanges<K>>]\n\nexport function partitionByKey<T, K, R>(\n  stream: Observable<T>,\n  keySelector: (value: T) => K,\n  streamSelector?: (grouped: Observable<T>, key: K) => Observable<R>,\n): [(key: K) => GroupedObservable<K, R>, Observable<KeyChanges<K>>] {\n  const groupedObservables$ = new Observable<{\n    groups: Map<K, InnerGroup<T, K, R>>\n    changes: KeyChanges<K>\n  }>((subscriber) => {\n    const groups: Map<K, InnerGroup<T, K, R>> = new Map()\n\n    let sourceCompleted = false\n    const finalize =\n      (type: \"error\" | \"complete\") =>\n      (...args: any[]) => {\n        sourceCompleted = true\n        if (groups.size) {\n          groups.forEach((g) => (g.source[type] as any)(...args))\n        } else {\n          subscriber[type](...args)\n        }\n      }\n\n    const sub = stream.subscribe(\n      (x) => {\n        const key = keySelector(x)\n        if (groups.has(key)) return groups.get(key)!.source.next(x)\n\n        let pendingFirstAdd = true\n        const emitFirstAdd = () => {\n          if (pendingFirstAdd) {\n            pendingFirstAdd = false\n            subscriber.next({\n              groups,\n              changes: {\n                type: \"add\",\n                keys: [key],\n              },\n            })\n          }\n        }\n\n        const subject = new Subject<T>()\n        let pendingFirstVal = true\n        const emitFirstValue = () => {\n          if (pendingFirstVal) {\n            pendingFirstVal = false\n            subject.next(x)\n          }\n        }\n\n        const shared$ = shareLatest()(\n          (streamSelector || identity)(subject, key),\n        )\n        const res = new Observable((observer) => {\n          incRefcount()\n          const subscription = shared$.subscribe(observer)\n          subscription.add(decRefcount)\n          emitFirstValue()\n          return subscription\n        }) as any as GroupedObservable<K, R>\n        ;(res as any).key = key\n\n        const innerGroup: InnerGroup<T, K, R> = {\n          source: subject,\n          observable: res,\n          subscription: new Subscription(),\n        }\n        groups.set(key, innerGroup)\n\n        innerGroup.subscription = shared$.subscribe(\n          noop,\n          (e) => subscriber.error(e),\n          () => {\n            groups.delete(key)\n            emitFirstAdd()\n            subscriber.next({\n              groups,\n              changes: {\n                type: \"remove\",\n                keys: [key],\n              },\n            })\n\n            if (groups.size === 0 && sourceCompleted) {\n              subscriber.complete()\n            }\n          },\n        )\n        emitFirstAdd()\n        emitFirstValue()\n      },\n      finalize(\"error\"),\n      finalize(\"complete\"),\n    )\n\n    return () => {\n      sub.unsubscribe()\n      groups.forEach((g) => {\n        g.source.unsubscribe()\n        g.subscription.unsubscribe()\n      })\n    }\n  }).pipe(shareLatest())\n\n  let refCount = 0\n  let sub: Subscription | undefined\n  function incRefcount() {\n    refCount++\n    if (refCount === 1) {\n      sub = groupedObservables$.subscribe()\n    }\n  }\n  function decRefcount() {\n    refCount--\n    if (refCount === 0) {\n      sub?.unsubscribe()\n    }\n  }\n\n  return [\n    (key: K) =>\n      getGroupedObservable(\n        groupedObservables$.pipe(map(({ groups }) => groups)),\n        key,\n      ),\n    groupedObservables$.pipe(\n      map((m, i): KeyChanges<K> => {\n        if (i === 0) {\n          // Replay all the previously added keys\n          return {\n            type: \"add\",\n            keys: m.groups.keys(),\n          }\n        }\n        return m.changes\n      }),\n    ),\n  ]\n}\n\ninterface InnerGroup<T, K, R> {\n  source: Subject<T>\n  observable: GroupedObservable<K, R>\n  subscription: Subscription\n}\n\nconst getGroupedObservable = <K, T>(\n  source$: Observable<Map<K, InnerGroup<any, K, T>>>,\n  key: K,\n) => {\n  const result = new Observable<T>((observer) => {\n    let innerSub: Subscription | undefined\n    let outerSub: Subscription | undefined\n    let foundSynchronously = false\n    outerSub = source$.subscribe(\n      (n) => {\n        const innerGroup = n.get(key)\n        if (innerGroup && !innerSub) {\n          innerSub = innerGroup.observable.subscribe(observer)\n          outerSub?.unsubscribe()\n          foundSynchronously = true\n        }\n      },\n      (e) => {\n        observer.error(e)\n      },\n      () => {\n        observer.complete()\n      },\n    )\n    if (foundSynchronously) {\n      outerSub.unsubscribe()\n      outerSub = undefined\n    }\n\n    return () => {\n      innerSub?.unsubscribe()\n      outerSub?.unsubscribe()\n    }\n  }) as GroupedObservable<K, T>\n  ;(result as any).key = key\n  return result\n}\n", "import { Observable, OperatorFunction } from \"rxjs\"\nimport { KeyChanges } from \"./partitionByKey\"\n\n/**\n * Operator function that maps a stream of KeyChanges into a Set that contains\n * the active keys.\n */\nexport function toKeySet<K>(): OperatorFunction<KeyChanges<K>, Set<K>> {\n  return (source$) =>\n    new Observable<Set<K>>((observer) => {\n      const result = new Set<K>()\n      let pristine = true\n      const subscription = source$.subscribe({\n        next({ type, keys }) {\n          const action = type === \"add\" ? type : \"delete\"\n          for (let k of keys) {\n            result[action](k)\n          }\n          observer.next(result)\n          pristine = false\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          observer.complete()\n        },\n      })\n      if (pristine) observer.next(result)\n      return subscription\n    })\n}\n", "import { ObservableInput, from, Observable } from \"rxjs\"\nimport { SUSPENSE } from \"@react-rxjs/core\"\nimport { defaultStart } from \"./internal-utils\"\n\n/**\n * A RxJS creation operator that prepends a SUSPENSE on the source observable.\n *\n * @param source$ Source observable\n */\nexport const suspend: <T>(\n  source$: ObservableInput<T>,\n) => Observable<T | typeof SUSPENSE> = <T>(source$: ObservableInput<T>) =>\n  defaultStart(SUSPENSE)(from(source$)) as any\n", "import { Observable } from \"rxjs\"\n\nexport const defaultStart =\n  <T, D>(value: D) =>\n  (source$: Observable<T>) =>\n    new Observable<T | D>((observer) => {\n      let emitted = false\n      const subscription = source$.subscribe(\n        (x) => {\n          emitted = true\n          observer.next(x)\n        },\n        (e) => {\n          observer.error(e)\n        },\n        () => {\n          observer.complete()\n        },\n      )\n\n      if (!emitted) {\n        observer.next(value)\n      }\n\n      return subscription\n    })\n", "import { suspend } from \"./suspend\"\nimport { OperatorFunction } from \"rxjs\"\nimport { SUSPENSE } from \"@react-rxjs/core\"\n\n/**\n * A RxJS pipeable operator that prepends a SUSPENSE on the source observable.\n */\nexport const suspended = <T>(): OperatorFunction<T, T | typeof SUSPENSE> =>\n  suspend\n", "import { ObservableInput, OperatorFunction, ObservedValueOf, pipe } from \"rxjs\"\nimport { switchMap } from \"rxjs/operators\"\nimport { suspend } from \"./suspend\"\nimport { SUSPENSE } from \"@react-rxjs/core\"\n\n/**\n * Same behaviour as rxjs' `switchMap`, but prepending every new event with\n * SUSPENSE.\n *\n * @param fn Projection function\n */\nexport const switchMapSuspended = <T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n): OperatorFunction<T, ObservedValueOf<O> | typeof SUSPENSE> =>\n  pipe(switchMap((x, index) => suspend(project(x, index))))\n", "import {\n  Observable,\n  Subject,\n  MonoTypeOperatorFunction,\n  BehaviorSubject,\n} from \"rxjs\"\nimport { switchAll, tap } from \"rxjs/operators\"\n\n/**\n * A creation operator that helps at creating observables that have circular\n * dependencies\n *\n * @returns [1, 2]\n * 1. The inner subject as an Observable\n * 2. A pipable operator that taps into the inner Subject\n */\nexport const selfDependent = <T>(): [\n  Observable<T>,\n  () => MonoTypeOperatorFunction<T>,\n] => {\n  const activeSubject: BehaviorSubject<Subject<T>> = new BehaviorSubject(\n    new Subject<T>(),\n  )\n  return [\n    activeSubject.pipe(switchAll()),\n    () =>\n      tap({\n        next: (v) => activeSubject.value.next(v),\n        error: (e) => {\n          activeSubject.value.error(e)\n          activeSubject.next(new Subject<T>())\n        },\n        complete: () => {\n          activeSubject.value.complete()\n          activeSubject.next(new Subject<T>())\n        },\n      }) as MonoTypeOperatorFunction<T>,\n  ]\n}\n\n/**\n * @deprecated renamed to `selfDependent`\n */\nexport const selfDependant = selfDependent\n", "import { Observable } from \"rxjs\"\nimport { bind, SUSPENSE } from \"@react-rxjs/core\"\n\ntype SubstractTuples<A1, A2> = A2 extends [unknown, ...infer Rest2]\n  ? A1 extends [unknown, ...infer Rest1]\n    ? SubstractTuples<Rest1, Rest2>\n    : []\n  : A1\n\nconst execSelf = <T>(fn: () => T) => fn()\n\n/**\n * Returns a version of bind where its hook will have the first parameters bound\n * the results of the provided functions\n *\n * @param {...React.Context} context - The React.Context that should be bound to the hook.\n */\nexport function contextBinder<\n  A extends (() => any)[],\n  OT extends {\n    [K in keyof A]: A[K] extends () => infer V ? V : unknown\n  },\n>(\n  ...args: A\n): <AA extends any[], T, ARGS extends [...OT, ...AA]>(\n  getObservable: (...args: ARGS) => Observable<T>,\n  defaultValue?: T | undefined,\n) => [\n  (...args: SubstractTuples<ARGS, OT>) => Exclude<T, typeof SUSPENSE>,\n  (...args: ARGS) => Observable<T>,\n]\nexport function contextBinder(...args: any[]) {\n  const useArgs = () => args.map(execSelf)\n  return function () {\n    const [hook, getter] = bind.apply(null, arguments as any) as any\n    return [(...args: any[]) => (hook as any)(...useArgs(), ...args), getter]\n  } as any\n}\n", "import { Observable } from \"rxjs\"\nimport { createSignal } from \"./createSignal\"\n\n/** @deprecated createListener is deprecated and it will be removed in the next version, please use createSignal. */\nexport function createListener<A extends unknown[], T>(\n  mapper: (...args: A) => T,\n): [Observable<T>, (...args: A) => void]\n\n/** @deprecated createListener is deprecated and it will be removed in the next version, please use createSignal. */\nexport function createListener(): [Observable<void>, () => void]\n\n/** @deprecated createListener is deprecated and it will be removed in the next version, please use createSignal. */\nexport function createListener<T>(): [Observable<T>, (payload: T) => void]\n\n/**\n * Creates a void signal. It's sugar for splitting the Observer and the Observable of a signal.\n *\n * @returns [1, 2]\n * 1. The Observable\n * 2. The emitter function.\n */\nexport function createListener(...args: any[]) {\n  return (createSignal as any)(...args)\n}\n"],
  "mappings": "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",
  "names": []
}
