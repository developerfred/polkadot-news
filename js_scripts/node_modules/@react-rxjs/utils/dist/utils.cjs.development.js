var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from3, except, desc) => {
  if (from3 && typeof from3 === "object" || typeof from3 === "function") {
    for (let key of __getOwnPropNames(from3))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.tsx
var src_exports = {};
__export(src_exports, {
  combineKeys: () => combineKeys,
  contextBinder: () => contextBinder,
  createKeyedSignal: () => createKeyedSignal,
  createListener: () => createListener,
  createSignal: () => createSignal,
  mergeWithKey: () => mergeWithKey,
  partitionByKey: () => partitionByKey,
  selfDependant: () => selfDependant,
  selfDependent: () => selfDependent,
  suspend: () => suspend,
  suspended: () => suspended,
  switchMapSuspended: () => switchMapSuspended,
  toKeySet: () => toKeySet
});
module.exports = __toCommonJS(src_exports);

// src/combineKeys.ts
var import_rxjs = require("rxjs");
var combineKeys = (keys$, getInner$) => new import_rxjs.Observable((observer) => {
  const innerSubscriptions = /* @__PURE__ */ new Map();
  let changes = /* @__PURE__ */ new Set();
  const currentValue = /* @__PURE__ */ new Map();
  let updatingSource = false;
  let isPristine = true;
  const next = () => {
    if (!updatingSource) {
      const result = Object.assign(currentValue, {
        changes
      });
      changes = /* @__PURE__ */ new Set();
      isPristine = false;
      observer.next(result);
    }
  };
  const subscription = keys$.subscribe((nextKeysArr) => {
    updatingSource = true;
    const keys = new Set(inputIsKeyChanges(nextKeysArr) ? nextKeysArr.keys : nextKeysArr);
    if (inputIsKeyChanges(nextKeysArr)) {
      if (nextKeysArr.type === "remove") {
        keys.forEach((key) => {
          const sub = innerSubscriptions.get(key);
          if (!sub)
            return;
          sub.unsubscribe();
          innerSubscriptions.delete(key);
          if (currentValue.has(key)) {
            changes.add(key);
            currentValue.delete(key);
          }
        });
        keys.clear();
      }
    } else {
      innerSubscriptions.forEach((sub, key) => {
        if (!keys.has(key)) {
          sub.unsubscribe();
          innerSubscriptions.delete(key);
          if (currentValue.has(key)) {
            changes.add(key);
            currentValue.delete(key);
          }
        } else {
          keys.delete(key);
        }
      });
    }
    keys.forEach((key) => {
      innerSubscriptions.set(key, getInner$(key).subscribe((x) => {
        if (!currentValue.has(key) || currentValue.get(key) !== x) {
          changes.add(key);
          currentValue.set(key, x);
          next();
        }
      }, (e) => {
        observer.error(e);
      }));
    });
    updatingSource = false;
    if (changes.size || isPristine && !keys.size)
      next();
  }, (e) => {
    observer.error(e);
  }, () => {
    observer.complete();
  });
  return () => {
    subscription.unsubscribe();
    innerSubscriptions.forEach((sub) => {
      sub.unsubscribe();
    });
  };
});
function inputIsKeyChanges(input) {
  return "type" in input && "keys" in input;
}

// src/createSignal.ts
var import_rxjs2 = require("rxjs");
function createSignal(mapper = import_rxjs2.identity) {
  const subject = new import_rxjs2.Subject();
  return [subject.asObservable(), (...args) => subject.next(mapper(...args))];
}

// src/createKeyedSignal.ts
var import_rxjs3 = require("rxjs");
function createKeyedSignal(keySelector, mapper) {
  const observersMap = /* @__PURE__ */ new Map();
  return [
    (key) => {
      const res = new import_rxjs3.Observable((observer) => {
        if (!observersMap.has(key)) {
          observersMap.set(key, /* @__PURE__ */ new Set());
        }
        const set = observersMap.get(key);
        set.add(observer);
        return () => {
          set.delete(observer);
          if (set.size === 0) {
            observersMap.delete(key);
          }
        };
      });
      res.key = key;
      return res;
    },
    (...args) => {
      var _a;
      const payload = mapper ? mapper(...args) : args.length === 2 ? args[1] : args[0];
      const key = keySelector ? keySelector(payload) : args[0];
      (_a = observersMap.get(key)) == null ? void 0 : _a.forEach((o) => {
        o.next(payload);
      });
    }
  ];
}

// src/mergeWithKey.ts
var import_rxjs4 = require("rxjs");
var import_operators = require("rxjs/operators");
var mergeWithKey = (input, ...optionalArgs) => (0, import_rxjs4.merge)(...Object.entries(input).map(([type, stream]) => (0, import_rxjs4.from)(stream).pipe((0, import_operators.map)((payload) => ({ type, payload })))).concat(optionalArgs));

// src/partitionByKey.ts
var import_core = require("@react-rxjs/core");
var import_rxjs5 = require("rxjs");
var import_operators2 = require("rxjs/operators");
function partitionByKey(stream, keySelector, streamSelector) {
  const groupedObservables$ = new import_rxjs5.Observable((subscriber) => {
    const groups = /* @__PURE__ */ new Map();
    let sourceCompleted = false;
    const finalize = (type) => (...args) => {
      sourceCompleted = true;
      if (groups.size) {
        groups.forEach((g) => g.source[type](...args));
      } else {
        subscriber[type](...args);
      }
    };
    const sub2 = stream.subscribe((x) => {
      const key = keySelector(x);
      if (groups.has(key))
        return groups.get(key).source.next(x);
      let pendingFirstAdd = true;
      const emitFirstAdd = () => {
        if (pendingFirstAdd) {
          pendingFirstAdd = false;
          subscriber.next({
            groups,
            changes: {
              type: "add",
              keys: [key]
            }
          });
        }
      };
      const subject = new import_rxjs5.Subject();
      let pendingFirstVal = true;
      const emitFirstValue = () => {
        if (pendingFirstVal) {
          pendingFirstVal = false;
          subject.next(x);
        }
      };
      const shared$ = (0, import_core.shareLatest)()((streamSelector || import_rxjs5.identity)(subject, key));
      const res = new import_rxjs5.Observable((observer) => {
        incRefcount();
        const subscription = shared$.subscribe(observer);
        subscription.add(decRefcount);
        emitFirstValue();
        return subscription;
      });
      res.key = key;
      const innerGroup = {
        source: subject,
        observable: res,
        subscription: new import_rxjs5.Subscription()
      };
      groups.set(key, innerGroup);
      innerGroup.subscription = shared$.subscribe(import_rxjs5.noop, (e) => subscriber.error(e), () => {
        groups.delete(key);
        emitFirstAdd();
        subscriber.next({
          groups,
          changes: {
            type: "remove",
            keys: [key]
          }
        });
        if (groups.size === 0 && sourceCompleted) {
          subscriber.complete();
        }
      });
      emitFirstAdd();
      emitFirstValue();
    }, finalize("error"), finalize("complete"));
    return () => {
      sub2.unsubscribe();
      groups.forEach((g) => {
        g.source.unsubscribe();
        g.subscription.unsubscribe();
      });
    };
  }).pipe((0, import_core.shareLatest)());
  let refCount = 0;
  let sub;
  function incRefcount() {
    refCount++;
    if (refCount === 1) {
      sub = groupedObservables$.subscribe();
    }
  }
  function decRefcount() {
    refCount--;
    if (refCount === 0) {
      sub == null ? void 0 : sub.unsubscribe();
    }
  }
  return [
    (key) => getGroupedObservable(groupedObservables$.pipe((0, import_operators2.map)(({ groups }) => groups)), key),
    groupedObservables$.pipe((0, import_operators2.map)((m, i) => {
      if (i === 0) {
        return {
          type: "add",
          keys: m.groups.keys()
        };
      }
      return m.changes;
    }))
  ];
}
var getGroupedObservable = (source$, key) => {
  const result = new import_rxjs5.Observable((observer) => {
    let innerSub;
    let outerSub;
    let foundSynchronously = false;
    outerSub = source$.subscribe((n) => {
      const innerGroup = n.get(key);
      if (innerGroup && !innerSub) {
        innerSub = innerGroup.observable.subscribe(observer);
        outerSub == null ? void 0 : outerSub.unsubscribe();
        foundSynchronously = true;
      }
    }, (e) => {
      observer.error(e);
    }, () => {
      observer.complete();
    });
    if (foundSynchronously) {
      outerSub.unsubscribe();
      outerSub = void 0;
    }
    return () => {
      innerSub == null ? void 0 : innerSub.unsubscribe();
      outerSub == null ? void 0 : outerSub.unsubscribe();
    };
  });
  result.key = key;
  return result;
};

// src/toKeySet.ts
var import_rxjs6 = require("rxjs");
function toKeySet() {
  return (source$) => new import_rxjs6.Observable((observer) => {
    const result = /* @__PURE__ */ new Set();
    let pristine = true;
    const subscription = source$.subscribe({
      next({ type, keys }) {
        const action = type === "add" ? type : "delete";
        for (let k of keys) {
          result[action](k);
        }
        observer.next(result);
        pristine = false;
      },
      error(e) {
        observer.error(e);
      },
      complete() {
        observer.complete();
      }
    });
    if (pristine)
      observer.next(result);
    return subscription;
  });
}

// src/suspend.ts
var import_rxjs8 = require("rxjs");
var import_core2 = require("@react-rxjs/core");

// src/internal-utils.ts
var import_rxjs7 = require("rxjs");
var defaultStart = (value) => (source$) => new import_rxjs7.Observable((observer) => {
  let emitted = false;
  const subscription = source$.subscribe((x) => {
    emitted = true;
    observer.next(x);
  }, (e) => {
    observer.error(e);
  }, () => {
    observer.complete();
  });
  if (!emitted) {
    observer.next(value);
  }
  return subscription;
});

// src/suspend.ts
var suspend = (source$) => defaultStart(import_core2.SUSPENSE)((0, import_rxjs8.from)(source$));

// src/suspended.ts
var suspended = () => suspend;

// src/switchMapSuspended.ts
var import_rxjs9 = require("rxjs");
var import_operators3 = require("rxjs/operators");
var switchMapSuspended = (project) => (0, import_rxjs9.pipe)((0, import_operators3.switchMap)((x, index) => suspend(project(x, index))));

// src/selfDependent.ts
var import_rxjs10 = require("rxjs");
var import_operators4 = require("rxjs/operators");
var selfDependent = () => {
  const activeSubject = new import_rxjs10.BehaviorSubject(new import_rxjs10.Subject());
  return [
    activeSubject.pipe((0, import_operators4.switchAll)()),
    () => (0, import_operators4.tap)({
      next: (v) => activeSubject.value.next(v),
      error: (e) => {
        activeSubject.value.error(e);
        activeSubject.next(new import_rxjs10.Subject());
      },
      complete: () => {
        activeSubject.value.complete();
        activeSubject.next(new import_rxjs10.Subject());
      }
    })
  ];
};
var selfDependant = selfDependent;

// src/contextBinder.ts
var import_core3 = require("@react-rxjs/core");
var execSelf = (fn) => fn();
function contextBinder(...args) {
  const useArgs = () => args.map(execSelf);
  return function() {
    const [hook, getter] = import_core3.bind.apply(null, arguments);
    return [(...args2) => hook(...useArgs(), ...args2), getter];
  };
}

// src/createListener.ts
function createListener(...args) {
  return createSignal(...args);
}
//# sourceMappingURL=utils.cjs.development.js.map
