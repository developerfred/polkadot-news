{
  "version": 3,
  "sources": ["../src/index.tsx", "../src/combineKeys.ts", "../src/createSignal.ts", "../src/createKeyedSignal.ts", "../src/mergeWithKey.ts", "../src/partitionByKey.ts", "../src/toKeySet.ts", "../src/suspend.ts", "../src/internal-utils.ts", "../src/suspended.ts", "../src/switchMapSuspended.ts", "../src/selfDependent.ts", "../src/contextBinder.ts", "../src/createListener.ts"],
  "sourcesContent": ["export { combineKeys, MapWithChanges } from \"./combineKeys\"\nexport { createSignal } from \"./createSignal\"\nexport { createKeyedSignal } from \"./createKeyedSignal\"\nexport { mergeWithKey } from \"./mergeWithKey\"\nexport { partitionByKey, KeyChanges } from \"./partitionByKey\"\nexport { toKeySet } from \"./toKeySet\"\nexport { suspend } from \"./suspend\"\nexport { suspended } from \"./suspended\"\nexport { switchMapSuspended } from \"./switchMapSuspended\"\nexport { selfDependent, selfDependant } from \"./selfDependent\"\nexport { contextBinder } from \"./contextBinder\"\nexport { createListener } from \"./createListener\"\n", "import { KeyChanges } from \"./partitionByKey\"\nimport { Observable, Subscription } from \"rxjs\"\n\nexport interface MapWithChanges<K, V> extends Map<K, V> {\n  changes: Set<K>\n}\n\n/**\n * Creates a stream that combines the result of the streams from each key of the input stream.\n *\n * @param keys$ Stream of the list of keys to subscribe to.\n * @param getInner$ Function that returns the stream for each key.\n * @returns An stream with a map containing the latest value from the stream of each key.\n */\nexport const combineKeys = <K, T>(\n  keys$: Observable<Iterable<K> | KeyChanges<K>>,\n  getInner$: (key: K) => Observable<T>,\n): Observable<MapWithChanges<K, T>> =>\n  new Observable((observer) => {\n    const innerSubscriptions = new Map<K, Subscription>()\n    let changes = new Set<K>()\n    const currentValue = new Map<K, T>()\n    let updatingSource = false\n    let isPristine = true\n\n    const next = () => {\n      if (!updatingSource) {\n        const result = Object.assign(currentValue, {\n          changes,\n        })\n        changes = new Set<K>()\n        isPristine = false\n        observer.next(result)\n      }\n    }\n\n    const subscription = keys$.subscribe(\n      (nextKeysArr) => {\n        updatingSource = true\n\n        const keys = new Set(\n          inputIsKeyChanges(nextKeysArr) ? nextKeysArr.keys : nextKeysArr,\n        )\n\n        if (inputIsKeyChanges(nextKeysArr)) {\n          if (nextKeysArr.type === \"remove\") {\n            keys.forEach((key) => {\n              const sub = innerSubscriptions.get(key)\n              if (!sub) return\n              sub.unsubscribe()\n              innerSubscriptions.delete(key)\n              if (currentValue.has(key)) {\n                changes.add(key)\n                currentValue.delete(key)\n              }\n            })\n            // Keys after this block is the list of keys to add. Clear it.\n            keys.clear()\n          }\n        } else {\n          innerSubscriptions.forEach((sub, key) => {\n            if (!keys.has(key)) {\n              sub.unsubscribe()\n              innerSubscriptions.delete(key)\n              if (currentValue.has(key)) {\n                changes.add(key)\n                currentValue.delete(key)\n              }\n            } else {\n              keys.delete(key)\n            }\n          })\n        }\n\n        keys.forEach((key) => {\n          innerSubscriptions.set(\n            key,\n            getInner$(key).subscribe(\n              (x) => {\n                if (!currentValue.has(key) || currentValue.get(key) !== x) {\n                  changes.add(key)\n                  currentValue.set(key, x)\n                  next()\n                }\n              },\n              (e) => {\n                observer.error(e)\n              },\n            ),\n          )\n        })\n\n        updatingSource = false\n        // If there are no changes but the nextKeys are an empty iterator\n        // and we have never emitted before, that means that the first\n        // value that keys$ has emitted is an empty iterator, therefore\n        // we should emit an empy Map\n        if (changes.size || (isPristine && !keys.size)) next()\n      },\n      (e) => {\n        observer.error(e)\n      },\n      () => {\n        observer.complete()\n      },\n    )\n\n    return () => {\n      subscription.unsubscribe()\n      innerSubscriptions.forEach((sub) => {\n        sub.unsubscribe()\n      })\n    }\n  })\n\nfunction inputIsKeyChanges<K>(\n  input: Iterable<K> | KeyChanges<K>,\n): input is KeyChanges<K> {\n  return \"type\" in input && \"keys\" in input\n}\n", "import { identity, Observable, Subject } from \"rxjs\"\n\n/**\n * Creates a signal. It's sugar for splitting the Observer and the Observable of a signal.\n *\n * @param mapper a mapper function, for mapping the arguments of the emitter function into\n * the value of the Observable.\n * @returns [1, 2]\n * 1. The Observable<T>\n * 2. The emitter function.\n */\nexport function createSignal<A extends unknown[], T>(\n  mapper: (...args: A) => T,\n): [Observable<T>, (...args: A) => void]\n\n/**\n * Creates a void signal. It's sugar for splitting the Observer and the Observable of a signal.\n *\n * @returns [1, 2]\n * 1. The Observable<void>\n * 2. The emitter function.\n */\nexport function createSignal(): [Observable<void>, () => void]\n\n/**\n * Creates a signal. It's sugar for splitting the Observer and the Observable of a signal.\n *\n * @returns [1, 2]\n * 1. The Observable<T>\n * 2. The emitter function.\n */\nexport function createSignal<T>(): [Observable<T>, (payload: T) => void]\n\nexport function createSignal<A extends unknown[], T>(\n  mapper: (...args: A) => T = identity as any,\n): [Observable<T>, (...args: A) => void] {\n  const subject = new Subject<T>()\n  return [subject.asObservable(), (...args: A) => subject.next(mapper(...args))]\n}\n", "import { GroupedObservable, Observable, Observer } from \"rxjs\"\n\n/**\n * Creates a \"keyed\" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.\n *\n * @returns [1, 2]\n * 1. The getter function that returns the GroupedObservable<T, T>\n * 2. The emitter function.\n */\nexport function createKeyedSignal<T>(): [\n  (key: T) => GroupedObservable<T, T>,\n  (key: T) => void,\n]\n\n/**\n * Creates a \"keyed\" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.\n *\n * @param keySelector a function that extracts the key from the emitted value\n * @returns [1, 2]\n * 1. The getter function that returns the GroupedObservable<K, T>\n * 2. The emitter function.\n */\nexport function createKeyedSignal<K, T>(): [\n  (key: K) => GroupedObservable<K, T>,\n  (key: K, value: T) => void,\n]\n\n/**\n * Creates a \"keyed\" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.\n *\n * @param keySelector a function that extracts the key from the emitted value\n * @returns [1, 2]\n * 1. The getter function that returns the GroupedObservable<K, T>\n * 2. The emitter function.\n */\nexport function createKeyedSignal<K, T>(\n  keySelector: (signal: T) => K,\n): [(key: K) => GroupedObservable<K, T>, (signal: T) => void]\n\n/**\n * Creates a \"keyed\" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.\n *\n * @param keySelector a function that extracts the key from the emitted value\n * @param mapper a function that maps the arguments of the emitter function to the value of the GroupedObservable\n * @returns [1, 2]\n * 1. The getter function that returns the GroupedObservable<K, T>\n * 2. The emitter function (...args: any[]) => T.\n */\nexport function createKeyedSignal<K, T, A extends any[]>(\n  keySelector: (signal: T) => K,\n  mapper: (...args: A) => T,\n): [(key: K) => GroupedObservable<K, T>, (...args: A) => void]\n\nexport function createKeyedSignal<K, T, A extends any[]>(\n  keySelector?: (signal: T) => K,\n  mapper?: (...args: A) => T,\n): [(key: K) => GroupedObservable<K, T>, (...args: A) => void] {\n  const observersMap = new Map<K, Set<Observer<T>>>()\n\n  return [\n    (key: K) => {\n      const res = new Observable<T>((observer) => {\n        if (!observersMap.has(key)) {\n          observersMap.set(key, new Set())\n        }\n        const set = observersMap.get(key)!\n        set.add(observer)\n        return () => {\n          set.delete(observer)\n          if (set.size === 0) {\n            observersMap.delete(key)\n          }\n        }\n      }) as GroupedObservable<K, T>\n      ;(res as any).key = key\n      return res\n    },\n    (...args: A) => {\n      const payload = mapper\n        ? mapper(...args)\n        : args.length === 2\n        ? args[1]\n        : args[0]\n      const key = keySelector ? keySelector(payload) : args[0]\n      observersMap.get(key)?.forEach((o) => {\n        o.next(payload)\n      })\n    },\n  ]\n}\n", "import { merge, Observable, ObservableInput, from, SchedulerLike } from \"rxjs\"\nimport { map } from \"rxjs/operators\"\n\n/**\n * Emits the values from all the streams of the provided object, in a result\n * which provides the key of the stream of that emission.\n *\n * @param input object of streams\n */\nexport const mergeWithKey: <\n  O extends { [P in keyof any]: ObservableInput<any> },\n  OT extends {\n    [K in keyof O]: O[K] extends ObservableInput<infer V>\n      ? { type: K; payload: V }\n      : unknown\n  },\n>(\n  x: O,\n  concurrent?: number,\n  scheduler?: SchedulerLike,\n) => Observable<OT[keyof O]> = (input, ...optionalArgs) =>\n  merge<any[]>(\n    ...(Object.entries(input)\n      .map(\n        ([type, stream]) =>\n          from(stream).pipe(\n            map((payload) => ({ type, payload } as any)),\n          ) as any,\n      )\n      .concat(optionalArgs) as any[]),\n  )\n", "import { shareLatest } from \"@react-rxjs/core\"\nimport {\n  GroupedObservable,\n  identity,\n  noop,\n  Observable,\n  Subject,\n  Subscription,\n} from \"rxjs\"\nimport { map } from \"rxjs/operators\"\n\nexport interface KeyChanges<K> {\n  type: \"add\" | \"remove\"\n  keys: Iterable<K>\n}\n\n/**\n * Groups the elements from the source stream by using `keySelector`, returning\n * a stream of the active keys, and a function to get the stream of a specific group\n *\n * @param stream Input stream\n * @param keySelector Function that specifies the key for each element in `stream`\n * @param streamSelector Function to apply to each resulting group\n * @returns [1, 2]\n * 1. A function that accepts a key and returns the stream for the group of that key.\n * 2. A stream of KeyChanges, an object that describes what keys have been added or deleted.\n */\nexport function partitionByKey<T, K, R>(\n  stream: Observable<T>,\n  keySelector: (value: T) => K,\n  streamSelector: (grouped: Observable<T>, key: K) => Observable<R>,\n): [(key: K) => GroupedObservable<K, R>, Observable<KeyChanges<K>>]\n\n/**\n * Groups the elements from the source stream by using `keySelector`, returning\n * a stream of the active keys, and a function to get the stream of a specific group\n *\n * @param stream Input stream\n * @param keySelector Function that specifies the key for each element in `stream`\n * @returns [1, 2]\n * 1. A function that accepts a key and returns the stream for the group of that key.\n * 2. A stream of KeyChanges, an object that describes what keys have been added or deleted.\n */\nexport function partitionByKey<T, K>(\n  stream: Observable<T>,\n  keySelector: (value: T) => K,\n): [(key: K) => GroupedObservable<K, T>, Observable<KeyChanges<K>>]\n\nexport function partitionByKey<T, K, R>(\n  stream: Observable<T>,\n  keySelector: (value: T) => K,\n  streamSelector?: (grouped: Observable<T>, key: K) => Observable<R>,\n): [(key: K) => GroupedObservable<K, R>, Observable<KeyChanges<K>>] {\n  const groupedObservables$ = new Observable<{\n    groups: Map<K, InnerGroup<T, K, R>>\n    changes: KeyChanges<K>\n  }>((subscriber) => {\n    const groups: Map<K, InnerGroup<T, K, R>> = new Map()\n\n    let sourceCompleted = false\n    const finalize =\n      (type: \"error\" | \"complete\") =>\n      (...args: any[]) => {\n        sourceCompleted = true\n        if (groups.size) {\n          groups.forEach((g) => (g.source[type] as any)(...args))\n        } else {\n          subscriber[type](...args)\n        }\n      }\n\n    const sub = stream.subscribe(\n      (x) => {\n        const key = keySelector(x)\n        if (groups.has(key)) return groups.get(key)!.source.next(x)\n\n        let pendingFirstAdd = true\n        const emitFirstAdd = () => {\n          if (pendingFirstAdd) {\n            pendingFirstAdd = false\n            subscriber.next({\n              groups,\n              changes: {\n                type: \"add\",\n                keys: [key],\n              },\n            })\n          }\n        }\n\n        const subject = new Subject<T>()\n        let pendingFirstVal = true\n        const emitFirstValue = () => {\n          if (pendingFirstVal) {\n            pendingFirstVal = false\n            subject.next(x)\n          }\n        }\n\n        const shared$ = shareLatest()(\n          (streamSelector || identity)(subject, key),\n        )\n        const res = new Observable((observer) => {\n          incRefcount()\n          const subscription = shared$.subscribe(observer)\n          subscription.add(decRefcount)\n          emitFirstValue()\n          return subscription\n        }) as any as GroupedObservable<K, R>\n        ;(res as any).key = key\n\n        const innerGroup: InnerGroup<T, K, R> = {\n          source: subject,\n          observable: res,\n          subscription: new Subscription(),\n        }\n        groups.set(key, innerGroup)\n\n        innerGroup.subscription = shared$.subscribe(\n          noop,\n          (e) => subscriber.error(e),\n          () => {\n            groups.delete(key)\n            emitFirstAdd()\n            subscriber.next({\n              groups,\n              changes: {\n                type: \"remove\",\n                keys: [key],\n              },\n            })\n\n            if (groups.size === 0 && sourceCompleted) {\n              subscriber.complete()\n            }\n          },\n        )\n        emitFirstAdd()\n        emitFirstValue()\n      },\n      finalize(\"error\"),\n      finalize(\"complete\"),\n    )\n\n    return () => {\n      sub.unsubscribe()\n      groups.forEach((g) => {\n        g.source.unsubscribe()\n        g.subscription.unsubscribe()\n      })\n    }\n  }).pipe(shareLatest())\n\n  let refCount = 0\n  let sub: Subscription | undefined\n  function incRefcount() {\n    refCount++\n    if (refCount === 1) {\n      sub = groupedObservables$.subscribe()\n    }\n  }\n  function decRefcount() {\n    refCount--\n    if (refCount === 0) {\n      sub?.unsubscribe()\n    }\n  }\n\n  return [\n    (key: K) =>\n      getGroupedObservable(\n        groupedObservables$.pipe(map(({ groups }) => groups)),\n        key,\n      ),\n    groupedObservables$.pipe(\n      map((m, i): KeyChanges<K> => {\n        if (i === 0) {\n          // Replay all the previously added keys\n          return {\n            type: \"add\",\n            keys: m.groups.keys(),\n          }\n        }\n        return m.changes\n      }),\n    ),\n  ]\n}\n\ninterface InnerGroup<T, K, R> {\n  source: Subject<T>\n  observable: GroupedObservable<K, R>\n  subscription: Subscription\n}\n\nconst getGroupedObservable = <K, T>(\n  source$: Observable<Map<K, InnerGroup<any, K, T>>>,\n  key: K,\n) => {\n  const result = new Observable<T>((observer) => {\n    let innerSub: Subscription | undefined\n    let outerSub: Subscription | undefined\n    let foundSynchronously = false\n    outerSub = source$.subscribe(\n      (n) => {\n        const innerGroup = n.get(key)\n        if (innerGroup && !innerSub) {\n          innerSub = innerGroup.observable.subscribe(observer)\n          outerSub?.unsubscribe()\n          foundSynchronously = true\n        }\n      },\n      (e) => {\n        observer.error(e)\n      },\n      () => {\n        observer.complete()\n      },\n    )\n    if (foundSynchronously) {\n      outerSub.unsubscribe()\n      outerSub = undefined\n    }\n\n    return () => {\n      innerSub?.unsubscribe()\n      outerSub?.unsubscribe()\n    }\n  }) as GroupedObservable<K, T>\n  ;(result as any).key = key\n  return result\n}\n", "import { Observable, OperatorFunction } from \"rxjs\"\nimport { KeyChanges } from \"./partitionByKey\"\n\n/**\n * Operator function that maps a stream of KeyChanges into a Set that contains\n * the active keys.\n */\nexport function toKeySet<K>(): OperatorFunction<KeyChanges<K>, Set<K>> {\n  return (source$) =>\n    new Observable<Set<K>>((observer) => {\n      const result = new Set<K>()\n      let pristine = true\n      const subscription = source$.subscribe({\n        next({ type, keys }) {\n          const action = type === \"add\" ? type : \"delete\"\n          for (let k of keys) {\n            result[action](k)\n          }\n          observer.next(result)\n          pristine = false\n        },\n        error(e) {\n          observer.error(e)\n        },\n        complete() {\n          observer.complete()\n        },\n      })\n      if (pristine) observer.next(result)\n      return subscription\n    })\n}\n", "import { ObservableInput, from, Observable } from \"rxjs\"\nimport { SUSPENSE } from \"@react-rxjs/core\"\nimport { defaultStart } from \"./internal-utils\"\n\n/**\n * A RxJS creation operator that prepends a SUSPENSE on the source observable.\n *\n * @param source$ Source observable\n */\nexport const suspend: <T>(\n  source$: ObservableInput<T>,\n) => Observable<T | typeof SUSPENSE> = <T>(source$: ObservableInput<T>) =>\n  defaultStart(SUSPENSE)(from(source$)) as any\n", "import { Observable } from \"rxjs\"\n\nexport const defaultStart =\n  <T, D>(value: D) =>\n  (source$: Observable<T>) =>\n    new Observable<T | D>((observer) => {\n      let emitted = false\n      const subscription = source$.subscribe(\n        (x) => {\n          emitted = true\n          observer.next(x)\n        },\n        (e) => {\n          observer.error(e)\n        },\n        () => {\n          observer.complete()\n        },\n      )\n\n      if (!emitted) {\n        observer.next(value)\n      }\n\n      return subscription\n    })\n", "import { suspend } from \"./suspend\"\nimport { OperatorFunction } from \"rxjs\"\nimport { SUSPENSE } from \"@react-rxjs/core\"\n\n/**\n * A RxJS pipeable operator that prepends a SUSPENSE on the source observable.\n */\nexport const suspended = <T>(): OperatorFunction<T, T | typeof SUSPENSE> =>\n  suspend\n", "import { ObservableInput, OperatorFunction, ObservedValueOf, pipe } from \"rxjs\"\nimport { switchMap } from \"rxjs/operators\"\nimport { suspend } from \"./suspend\"\nimport { SUSPENSE } from \"@react-rxjs/core\"\n\n/**\n * Same behaviour as rxjs' `switchMap`, but prepending every new event with\n * SUSPENSE.\n *\n * @param fn Projection function\n */\nexport const switchMapSuspended = <T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n): OperatorFunction<T, ObservedValueOf<O> | typeof SUSPENSE> =>\n  pipe(switchMap((x, index) => suspend(project(x, index))))\n", "import {\n  Observable,\n  Subject,\n  MonoTypeOperatorFunction,\n  BehaviorSubject,\n} from \"rxjs\"\nimport { switchAll, tap } from \"rxjs/operators\"\n\n/**\n * A creation operator that helps at creating observables that have circular\n * dependencies\n *\n * @returns [1, 2]\n * 1. The inner subject as an Observable\n * 2. A pipable operator that taps into the inner Subject\n */\nexport const selfDependent = <T>(): [\n  Observable<T>,\n  () => MonoTypeOperatorFunction<T>,\n] => {\n  const activeSubject: BehaviorSubject<Subject<T>> = new BehaviorSubject(\n    new Subject<T>(),\n  )\n  return [\n    activeSubject.pipe(switchAll()),\n    () =>\n      tap({\n        next: (v) => activeSubject.value.next(v),\n        error: (e) => {\n          activeSubject.value.error(e)\n          activeSubject.next(new Subject<T>())\n        },\n        complete: () => {\n          activeSubject.value.complete()\n          activeSubject.next(new Subject<T>())\n        },\n      }) as MonoTypeOperatorFunction<T>,\n  ]\n}\n\n/**\n * @deprecated renamed to `selfDependent`\n */\nexport const selfDependant = selfDependent\n", "import { Observable } from \"rxjs\"\nimport { bind, SUSPENSE } from \"@react-rxjs/core\"\n\ntype SubstractTuples<A1, A2> = A2 extends [unknown, ...infer Rest2]\n  ? A1 extends [unknown, ...infer Rest1]\n    ? SubstractTuples<Rest1, Rest2>\n    : []\n  : A1\n\nconst execSelf = <T>(fn: () => T) => fn()\n\n/**\n * Returns a version of bind where its hook will have the first parameters bound\n * the results of the provided functions\n *\n * @param {...React.Context} context - The React.Context that should be bound to the hook.\n */\nexport function contextBinder<\n  A extends (() => any)[],\n  OT extends {\n    [K in keyof A]: A[K] extends () => infer V ? V : unknown\n  },\n>(\n  ...args: A\n): <AA extends any[], T, ARGS extends [...OT, ...AA]>(\n  getObservable: (...args: ARGS) => Observable<T>,\n  defaultValue?: T | undefined,\n) => [\n  (...args: SubstractTuples<ARGS, OT>) => Exclude<T, typeof SUSPENSE>,\n  (...args: ARGS) => Observable<T>,\n]\nexport function contextBinder(...args: any[]) {\n  const useArgs = () => args.map(execSelf)\n  return function () {\n    const [hook, getter] = bind.apply(null, arguments as any) as any\n    return [(...args: any[]) => (hook as any)(...useArgs(), ...args), getter]\n  } as any\n}\n", "import { Observable } from \"rxjs\"\nimport { createSignal } from \"./createSignal\"\n\n/** @deprecated createListener is deprecated and it will be removed in the next version, please use createSignal. */\nexport function createListener<A extends unknown[], T>(\n  mapper: (...args: A) => T,\n): [Observable<T>, (...args: A) => void]\n\n/** @deprecated createListener is deprecated and it will be removed in the next version, please use createSignal. */\nexport function createListener(): [Observable<void>, () => void]\n\n/** @deprecated createListener is deprecated and it will be removed in the next version, please use createSignal. */\nexport function createListener<T>(): [Observable<T>, (payload: T) => void]\n\n/**\n * Creates a void signal. It's sugar for splitting the Observer and the Observable of a signal.\n *\n * @returns [1, 2]\n * 1. The Observable\n * 2. The emitter function.\n */\nexport function createListener(...args: any[]) {\n  return (createSignal as any)(...args)\n}\n"],
  "mappings": "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",
  "names": []
}
